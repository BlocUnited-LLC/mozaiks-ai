# Workflow Development Framework - Plugin Contracts & Templates

## Overview

This document defines the plugin contract system for creating modular, templated workflows that can be generated by LLMs or built by developers using standardized patterns.

## ðŸŽ¯ Design Goals

1. **Template-Driven Development**: JSON/YAML configs generate complete workflows
2. **Plugin Contracts**: Standardized interfaces for all workflow components
3. **LLM-Friendly**: Clear instructions for automated workflow generation
4. **Developer-Friendly**: Simple patterns for manual development
5. **Hot-Pluggable**: Add/remove workflows without system changes

## ðŸ“‹ Plugin Contract System

### Core Contract Interface

Every workflow component follows standardized contracts:

```typescript
// Component Contract Interface
interface ComponentContract {
  metadata: ComponentMetadata;
  props: ComponentProps;
  actions: ComponentActions;
  handlers: ComponentHandlers;
}

interface ComponentMetadata {
  name: string;
  type: 'inline' | 'artifact';
  version: string;
  description: string;
  author?: string;
  dependencies?: string[];
}

interface ComponentProps {
  required: string[];
  optional: string[];
  schema: JSONSchema;
}

interface ComponentActions {
  [actionName: string]: ActionDefinition;
}

interface ComponentHandlers {
  backend: string;        // Python file path
  functions: string[];    // Function names
}
```

## ðŸ—ï¸ Workflow Template Structure

### Standard Directory Template

```
workflows/{WorkflowName}/
â”œâ”€â”€ workflow.yaml                 # Main configuration
â”œâ”€â”€ metadata.json                 # Workflow metadata
â”œâ”€â”€ templates/                    # Generated files
â”‚   â”œâ”€â”€ agents.py                # Auto-generated from config
â”‚   â”œâ”€â”€ context_variables.py     # Auto-generated from config
â”‚   â”œâ”€â”€ handoffs.py              # Auto-generated from config
â”‚   â””â”€â”€ tools.py                 # Auto-generated from config
â”œâ”€â”€ Components/
â”‚   â”œâ”€â”€ Artifacts/               # Full-featured components
â”‚   â”‚   â”œâ”€â”€ {ComponentName}.js   # React component
â”‚   â”‚   â””â”€â”€ {ComponentName}.yaml # Component contract
â”‚   â””â”€â”€ Inline/                  # Lightweight components
â”‚       â”œâ”€â”€ {ComponentName}.js   # React component
â”‚       â””â”€â”€ {ComponentName}.yaml # Component contract
â”œâ”€â”€ GroupchatTools/              # Backend handlers
â”‚   â”œâ”€â”€ __init__.py             # Auto-generated
â”‚   â”œâ”€â”€ handlers.py             # Auto-generated from contracts
â”‚   â””â”€â”€ custom.py               # Manual overrides
â””â”€â”€ generated/                   # Auto-generated files
    â”œâ”€â”€ manifest.json           # Component registry
    â””â”€â”€ schema.json             # Validation schema
```

## ðŸ“ Configuration Templates

### 1. Main Workflow Configuration

```yaml
# workflow.yaml
metadata:
  name: "ContentGenerator"
  version: "1.0.0"
  description: "AI content generation workflow"
  author: "YourName"
  
configuration:
  human_in_the_loop: true
  transport: "sse"
  auto_start: false
  
agents:
  - name: "ConversationAgent"
    type: "conversational"
    capabilities: ["chat", "inline_components"]
    model: "gpt-4"
    system_message: |
      You are a helpful conversation agent that guides users through content generation.
      You can request API keys and user preferences using inline components.
    
  - name: "ContentGeneratorAgent" 
    type: "specialist"
    capabilities: ["artifacts", "file_generation"]
    model: "gpt-4"
    system_message: |
      You generate high-quality content and provide it as downloadable files.
      Use artifact components to display generated content.

context_variables:
  - name: "user_preferences"
    type: "object"
    default: {}
    description: "User content preferences"
    
  - name: "api_keys"
    type: "object"
    default: {}
    description: "Stored API keys for services"

handoffs:
  - from: "ConversationAgent"
    to: "ContentGeneratorAgent"
    condition: "has_required_inputs"
    
  - from: "ContentGeneratorAgent"
    to: "ConversationAgent"
    condition: "content_generated"

components:
  inline:
    - name: "APIKeyInput"
      required_props: ["service", "agentId"]
      actions: ["submit", "cancel"]
      
    - name: "PreferencesForm"
      required_props: ["fields"]
      actions: ["submit", "reset"]
      
  artifacts:
    - name: "FileDownloadCenter"
      required_props: ["files"]
      actions: ["download", "download_all"]
      
    - name: "ContentPreview"
      required_props: ["content", "type"]
      actions: ["approve", "edit", "regenerate"]

tools:
  - name: "store_api_key"
    component: "APIKeyInput"
    handler: "db_manager.store_api_key"
    
  - name: "save_preferences"
    component: "PreferencesForm" 
    handler: "preferences.save_user_preferences"
    
  - name: "generate_files"
    component: "FileDownloadCenter"
    handler: "file_manager.create_downloadable_files"
```

### 2. Component Contract Template

```yaml
# Components/Inline/APIKeyInput.yaml
metadata:
  name: "APIKeyInput"
  type: "inline"
  version: "1.0.0"
  description: "Secure API key collection component"
  
contract:
  props:
    required:
      - service: "string"
      - agentId: "string"
    optional:
      - placeholder: "string"
      - description: "string"
      - validationPattern: "string"
      
  actions:
    submit:
      payload_schema:
        type: "object"
        properties:
          service: { type: "string" }
          apiKey: { type: "string" }
          maskedKey: { type: "string" }
      handler: "db_manager.store_api_key"
      
    cancel:
      payload_schema:
        type: "object"
        properties:
          reason: { type: "string" }
      handler: "session.handle_cancellation"

backend:
  module: "GroupchatTools.db_manager"
  functions:
    - "store_api_key"
    - "get_api_key"
    - "delete_api_key"
    
validation:
  required_backend_functions:
    - "store_api_key"
  optional_backend_functions:
    - "get_api_key"
    - "delete_api_key"
```

## ðŸ”§ Code Generation Templates

### 1. Agent Template (Jinja2)

```python
# templates/agents.py.j2
"""
Auto-generated agents for {{ metadata.name }} workflow
Generated from workflow.yaml on {{ generation_date }}
"""

from autogen import ConversableAgent
from core.workflow.tool_registry import get_workflow_tools

{% for agent in agents %}
class {{ agent.name }}(ConversableAgent):
    """{{ agent.description or 'Auto-generated agent' }}"""
    
    def __init__(self, **kwargs):
        super().__init__(
            name="{{ agent.name }}",
            llm_config={
                "model": "{{ agent.model }}",
                "api_type": "openai"
            },
            system_message="""{{ agent.system_message }}""",
            **kwargs
        )
        
        # Register workflow-specific tools
        {% if agent.capabilities %}
        self.tools = get_workflow_tools(
            workflow_name="{{ metadata.name }}",
            capabilities={{ agent.capabilities }}
        )
        {% endif %}

{% endfor %}

# Agent registry for workflow
AGENTS = {
    {% for agent in agents %}
    "{{ agent.name }}": {{ agent.name }},
    {% endfor %}
}
```

### 2. Context Variables Template

```python
# templates/context_variables.py.j2
"""
Auto-generated context variables for {{ metadata.name }} workflow
"""

from typing import Dict, Any, Optional
from dataclasses import dataclass, field

@dataclass
class {{ metadata.name }}Context:
    """Context variables for {{ metadata.name }} workflow"""
    
    {% for var in context_variables %}
    {{ var.name }}: {{ var.type }} = field(
        default_factory=lambda: {{ var.default }},
        metadata={"description": "{{ var.description }}"}
    )
    {% endfor %}
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for AG2 context"""
        return {
            {% for var in context_variables %}
            "{{ var.name }}": self.{{ var.name }},
            {% endfor %}
        }
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "{{ metadata.name }}Context":
        """Create from dictionary"""
        return cls(
            {% for var in context_variables %}
            {{ var.name }}=data.get("{{ var.name }}", {{ var.default }}),
            {% endfor %}
        )
```

### 3. Component Handler Template

```python
# templates/handlers.py.j2
"""
Auto-generated component handlers for {{ metadata.name }} workflow
"""

from typing import Dict, Any, Optional
import logging

logger = logging.getLogger(__name__)

{% for component in components.inline + components.artifacts %}
{% set contract = load_component_contract(component.name) %}

class {{ component.name }}Handler:
    """Handler for {{ component.name }} component"""
    
    {% for action_name, action in contract.actions.items() %}
    async def handle_{{ action_name }}(self, payload: Dict[str, Any]) -> Dict[str, Any]:
        """
        Handle {{ action_name }} action from {{ component.name }}
        
        Payload Schema: {{ action.payload_schema }}
        """
        try:
            # Validate payload
            self._validate_payload(payload, {{ action.payload_schema }})
            
            # TODO: Implement business logic
            logger.info(f"Handling {{ action_name }} for {{ component.name }}")
            
            return {"status": "success", "message": "{{ action_name }} completed"}
            
        except Exception as e:
            logger.error(f"Error handling {{ action_name }}: {e}")
            return {"status": "error", "message": str(e)}
    
    {% endfor %}
    
    def _validate_payload(self, payload: Dict[str, Any], schema: Dict[str, Any]):
        """Validate payload against schema"""
        # TODO: Implement JSON schema validation
        pass

{% endfor %}
```

## ðŸ“š Developer Documentation Templates

### 1. Component Development Guide

```markdown
# {{ component.name }} Component Development Guide

## Overview
{{ component.description }}

## Contract
This component follows the {{ component.type }} component contract.

### Required Props
{% for prop in contract.props.required %}
- `{{ prop.name }}` ({{ prop.type }}): {{ prop.description }}
{% endfor %}

### Optional Props  
{% for prop in contract.props.optional %}
- `{{ prop.name }}` ({{ prop.type }}): {{ prop.description }}
{% endfor %}

### Actions
{% for action_name, action in contract.actions.items %}
#### {{ action_name }}
{{ action.description }}

**Payload Schema:**
```json
{{ action.payload_schema | tojsonpretty }}
```

**Backend Handler:** `{{ action.handler }}`
{% endfor %}

## Implementation Checklist

### Frontend (React Component)
- [ ] Implement required props validation
- [ ] Handle all defined actions
- [ ] Call `onAction` for user interactions
- [ ] Follow design system guidelines

### Backend (Python Handler)
- [ ] Implement handler functions
- [ ] Validate incoming payloads
- [ ] Handle errors gracefully
- [ ] Log business events

## Code Templates

### React Component Template
```javascript
const {{ component.name }} = ({ 
  {% for prop in contract.props.required %}{{ prop.name }}, {% endfor %}
  onAction,
  ...props 
}) => {
  // Component implementation
};
```

### Python Handler Template
```python
async def handle_action(self, payload: Dict[str, Any]):
    # Handler implementation
    pass
```
```

### 2. Workflow Creation Guide

```markdown
# Workflow Creation Guide

## Quick Start

1. **Create workflow directory:**
   ```bash
   mkdir workflows/MyWorkflow
   cd workflows/MyWorkflow
   ```

2. **Create workflow.yaml:**
   ```yaml
   metadata:
     name: "MyWorkflow"
     description: "My custom workflow"
   
   agents:
     - name: "MyAgent"
       model: "gpt-4"
       capabilities: ["chat"]
   ```

3. **Generate templates:**
   ```bash
   python tools/generate_workflow.py MyWorkflow
   ```

4. **Implement custom logic:**
   - Edit `GroupchatTools/custom.py`
   - Create components in `Components/`

## Template Variables

### Agent Configuration
- `name`: Agent identifier
- `model`: LLM model to use
- `capabilities`: List of UI capabilities
- `system_message`: Agent instructions

### Component Configuration
- `name`: Component identifier
- `type`: "inline" or "artifact"
- `required_props`: Required properties
- `actions`: User interaction handlers

## Best Practices

1. **Keep components focused:** One responsibility per component
2. **Use descriptive names:** Clear naming for agents and components  
3. **Validate inputs:** Always validate user inputs
4. **Handle errors:** Graceful error handling and user feedback
5. **Log events:** Log business events for debugging
```

## ðŸš€ Implementation Strategy

### Phase 1: Template Engine
1. Create Jinja2 template system
2. Build workflow generator CLI tool
3. Implement contract validation

### Phase 2: Developer Tools
1. Component scaffolding commands
2. Live validation during development
3. Hot-reload for rapid iteration

### Phase 3: LLM Integration
1. LLM-friendly instruction format
2. Automated workflow generation
3. Validation and testing tools

## ðŸ”§ CLI Tools

```bash
# Generate new workflow from template
python tools/create_workflow.py --name "MyWorkflow" --template "basic"

# Generate component from contract
python tools/create_component.py --workflow "MyWorkflow" --name "MyComponent" --type "inline"

# Validate workflow configuration
python tools/validate_workflow.py --workflow "MyWorkflow"

# Generate all templates for workflow
python tools/generate_templates.py --workflow "MyWorkflow"
```

This framework makes workflow creation as simple as filling out YAML configs while maintaining full flexibility for custom logic!
