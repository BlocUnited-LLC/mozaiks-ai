{
  "structured_outputs": {
    "models": {
      "AgentTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Tool function name (snake_case). The actual callable that the agent invokes."
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service this tool interacts with (PascalCase). Examples: 'Stripe', 'Slack', 'OpenAI', 'GitHub'. Use null for tools that don't require external API calls."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of what this tool does and why the agent needs it (<=140 chars)."
          },
          "interaction_mode": {
            "type": "literal",
            "values": [
              "inline",
              "artifact",
              "none"
            ],
            "description": "Interaction surface for this tool: inline (chat-embedded), artifact (side panel or tray), none (backend-only or silent)."
          }
        }
      },
      "LifecycleTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Lifecycle tool function name (snake_case). The actual callable that executes the lifecycle operation."
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service this lifecycle tool interacts with (PascalCase). Use null for internal-only operations."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of what this lifecycle operation does (<=140 chars)."
          },
          "trigger": {
            "type": "literal",
            "values": [
              "before_agent",
              "after_agent"
            ],
            "description": "When this lifecycle operation executes relative to the agent's main work."
          }
        }
      },
      "SystemHook": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Hook function name (snake_case). The actual callable that executes the hook logic."
          },
          "agent": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Agent name this hook applies to. Use null for global hooks."
          },
          "trigger": {
            "type": "literal",
            "values": [
              "process_message_before_send",
              "update_agent_state",
              "process_last_received_message",
              "process_all_messages_before_reply"
            ],
            "description": "The AG2 hook trigger point."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of why this hook is needed (<=140 chars)."
          }
        }
      },
      "WorkflowAgent": {
        "type": "model",
        "fields": {
          "agent_name": {
            "type": "str",
            "description": "Agent identifier (unique within the workflow)"
          },
          "agent_type": {
            "type": "str",
            "description": "Descriptive architectural role of the agent (e.g., 'Research Specialist', 'Code Reviewer')."
          },
          "objective": {
            "type": "str",
            "description": "Short human-readable description of the agent's responsibilities (displayed in the UI)."
          },
          "agent_tools": {
            "type": "list",
            "items": "AgentTool",
            "description": "Agent-specific tools this agent can call. Each tool specifies name, integration, and purpose. Use [] when no agent tools are required."
          },
          "lifecycle_tools": {
            "type": "list",
            "items": "LifecycleTool",
            "description": "Lifecycle operation tools this agent executes. Each tool specifies name, integration, purpose, and trigger timing. Use [] when no lifecycle tools are required."
          },
          "system_hooks": {
            "type": "list",
            "items": "SystemHook",
            "description": "System hooks this agent uses for runtime behavior modification. Each hook specifies name, trigger, and purpose. Use [] when no system hooks are required."
          },
          "human_interaction": {
            "type": "literal",
            "values": [
              "none",
              "context",
              "approval",
              "feedback",
              "single"
            ],
            "description": "Human involvement mode for THIS SPECIFIC AGENT. none = fully automated execution; context = conversational data collection or clarification; approval = explicit sign-off/decision gate; feedback = non-UI iterative refinement; single = one-shot invocation."
          },
          "generation_mode": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Generation mode for generator agents: allowed values text, image, video, audio. Use null for non-generator agents."
          }
        }
      },
      "MermaidSequenceDiagram": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Workflow name this diagram represents"
          },
          "mermaid_diagram": {
            "type": "str",
            "description": "Complete Mermaid sequence diagram text, beginning with 'sequenceDiagram'. Must include required blank line after participant declarations."
          },
          "legend": {
            "type": "list",
            "items": "str",
            "description": "Optional module legend entries (M1: Module Name). Provide [] when no legend is required."
          }
        }
      },
      "DerivedTriggerMatch": {
        "type": "model",
        "fields": {
          "equals": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Exact string match required for the trigger (agent_text only)."
          },
          "contains": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Substring match evaluated against emitted agent text (agent_text only)."
          },
          "regex": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Regular expression applied to emitted agent text (agent_text only)."
          }
        }
      },
      "DerivedTrigger": {
        "type": "model",
        "fields": {
          "type": {
            "type": "literal",
            "values": [
              "agent_text",
              "ui_response"
            ],
            "description": "Trigger mode: agent_text (passive detection) or ui_response (active UI tool response)."
          },
          "agent": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Agent whose output is monitored (required when type=agent_text)."
          },
          "match": {
            "type": "union",
            "variants": [
              "DerivedTriggerMatch",
              "null"
            ],
            "description": "Match conditions for agent_text triggers. Must be omitted for ui_response triggers."
          },
          "tool": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Snake_case tool name responsible for updating the variable (required when type=ui_response)."
          },
          "response_key": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Key in the UI tool response payload whose value seeds the state variable (required when type=ui_response)."
          },
          "ui_hidden": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Whether to hide the agent's text output from the user UI (agent_text triggers only). True = hide token (e.g. NEXT), False = show message."
          }
        }
      },
      "ContextVariableSource": {
        "type": "model",
        "fields": {
          "type": {
            "type": "literal",
            "values": [
              "config",
              "data_reference",
              "data_entity",
              "computed",
              "state",
              "external"
            ],
            "description": "Source classification: config (deployment configuration from env vars), data_reference (read existing MongoDB data), data_entity (create new MongoDB data), computed (business logic outputs), state (workflow orchestration state with transitions), external (third-party API data with caching/retry)."
          },
          "env_var": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Environment variable name (config sources only, UPPER_SNAKE_CASE)."
          },
          "default": {
            "type": "union",
            "variants": [
              "str",
              "int",
              "bool",
              "null"
            ],
            "description": "Fallback value when the source is unavailable (config, computed, state sources)."
          },
          "required": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Whether this config variable is required (config sources only)."
          },
          "database_name": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Mongo database name (data_reference and data_entity sources only)."
          },
          "collection": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Mongo collection name (data_reference and data_entity sources only)."
          },
          "query_template": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "MongoDB query template with ${var} placeholders (data_reference sources only)."
          },
          "fields": {
            "type": "union",
            "variants": [
              "list",
              "null"
            ],
            "description": "List of fields to extract from query result (data_reference sources only)."
          },
          "refresh_strategy": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "When to refresh data: 'once' (cache indefinitely), 'per_module' (refresh each module), 'on_demand' (refresh when requested). Data_reference sources only."
          },
          "schema": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "JSON schema for the entity structure (data_entity sources only)."
          },
          "indexes": {
            "type": "union",
            "variants": [
              "list",
              "null"
            ],
            "description": "MongoDB index definitions for this entity (data_entity sources only)."
          },
          "write_strategy": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "When to persist entity: 'immediate' (on creation), 'on_module_transition', 'on_workflow_end'. Data_entity sources only."
          },
          "search_by": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Field used to locate/update the entity (data_entity sources only)."
          },
          "computation": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Description of the computation logic (computed sources only)."
          },
          "inputs": {
            "type": "union",
            "variants": [
              "list",
              "null"
            ],
            "description": "List of input variable names required for computation (computed sources only)."
          },
          "output_type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Expected output data type (computed sources only)."
          },
          "persist_to": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "Optional MongoDB persistence config (computed sources only)."
          },
          "transitions": {
            "type": "union",
            "variants": [
              "list",
              "null"
            ],
            "description": "State transition definitions with triggers (state sources only)."
          },
          "persist": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Whether to persist state across sessions (state sources only)."
          },
          "service": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service name (external sources only, e.g., 'Stripe', 'OpenAI')."
          },
          "operation": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "API operation or endpoint (external sources only)."
          },
          "params": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "API request parameters with ${var} placeholders (external sources only)."
          },
          "auth": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "Authentication configuration (external sources only)."
          },
          "cache": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "Cache configuration with TTL (external sources only)."
          },
          "retry": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "Retry policy for failed requests (external sources only)."
          },
          "triggers": {
            "type": "list",
            "items": "DerivedTrigger",
            "description": "Trigger definitions for state sources with transitions. Use [] for other types.",
            "default": []
          }
        }
      },
      "ContextVariableDefinitionEntry": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Unique snake_case variable name."
          },
          "type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Canonical data type for downstream casting (string|integer|boolean etc.)."
          },
          "description": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Human readable description explaining the variable purpose."
          },
          "source": {
            "type": "ContextVariableSource",
            "description": "Source metadata describing where the value originates."
          }
        }
      },
      "ContextVariableAgentExposure": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Agent name receiving these variables."
          },
          "variables": {
            "type": "list",
            "items": "str",
            "description": "Variables exposed to the agent (empty list permitted).",
            "default": []
          }
        }
      },
      "ContextVariablesPlan": {
        "type": "model",
        "fields": {
          "definitions": {
            "type": "list",
            "items": "ContextVariableDefinitionEntry",
            "description": "Ordered list of context variable definitions (each entry includes name, type, description, and source metadata)."
          },
          "agents": {
            "type": "list",
            "items": "ContextVariableAgentExposure",
            "description": "Agent exposure entries describing which variables are visible to each agent."
          }
        }
      },
      "UIConfig": {
        "type": "model",
        "fields": {
          "component": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "React component name (UI_Tool only)"
          },
          "mode": {
            "type": "literal",
            "values": [
              "inline",
              "artifact"
            ],
            "description": "Placement hint for ChatUI. Mirrors the existing tools.json schema (inline vs artifact). Optional; omit to fall back to runtime defaults."
          }
        }
      },
      "ToolSpec": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Owning agent (or primary agent)"
          },
          "file": {
            "type": "str",
            "description": "Python module file name"
          },
          "function": {
            "type": "str",
            "description": "Async function inside the file"
          },
          "description": {
            "type": "str",
            "description": "Tool purpose (<=140 chars, no secrets)"
          },
          "tool_type": {
            "type": "literal",
            "values": [
              "UI_Tool",
              "Agent_Tool"
            ],
            "description": "Tool type"
          },
          "auto_invoke": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Controls whether tool is automatically invoked when agent produces structured output. Default: true for UI_Tool, false for Agent_Tool. Set true for Agent_Tools whose structured output must be stored in context for downstream agents to access. Omit (null) to use defaults."
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service this tool integrates with (e.g., 'Slack', 'GitHub'). Use null for internal tools."
          },
          "ui": {
            "type": "UIConfig",
            "description": "UI metadata (component + mode). Use null for Agent_Tool entries."
          }
        }
      },
      "LifecycleToolSpec": {
        "type": "model",
        "fields": {
          "trigger": {
            "type": "literal",
            "values": [
              "before_chat",
              "after_chat",
              "before_agent",
              "after_agent"
            ],
            "description": "Lifecycle boundary where the hook executes."
          },
          "agent": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Agent name when the lifecycle tool is scoped to a single agent; null for chat-level hooks."
          },
          "file": {
            "type": "str",
            "description": "Python module file name"
          },
          "function": {
            "type": "str",
            "description": "Async function inside the file"
          },
          "description": {
            "type": "str",
            "description": "Lifecycle purpose (<=140 chars, no secrets)"
          },
          "tool_type": {
            "type": "literal",
            "values": [
              "UI_Tool",
              "Agent_Tool"
            ],
            "description": "Classification for parity with runtime loader (defaults to UI_Tool today)."
          },
          "auto_invoke": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Controls whether tool is automatically invoked when agent produces structured output. Default: true for UI_Tool, false for Agent_Tool. Set true for Agent_Tools whose structured output must be stored in context for downstream agents to access. Omit (null) to use defaults."
          },
          "ui": {
            "type": "UIConfig",
            "description": "Optional UI metadata when lifecycle operations surface a UI_Tool (matches tools.json)."
          }
        }
      },
      "HookFile": {
        "type": "model",
        "fields": {
          "filename": {
            "type": "str",
            "description": "Hook file name (e.g., 'validate_budget.py', 'audit_decisions.py')"
          },
          "hook_type": {
            "type": "literal",
            "values": [
              "before_chat",
              "after_chat",
              "update_agent_state",
              "process_message_before_send",
              "process_last_received_message",
              "process_all_messages_before_reply"
            ],
            "description": "Lifecycle or system hook type"
          },
          "py_content": {
            "type": "str",
            "description": "Complete Python code for hook function"
          }
        }
      },
      "PromptSection": {
        "type": "model",
        "description": "Content container for a single prompt section (id + heading + text)",
        "fields": {
          "id": {
            "type": "str",
            "description": "Section identifier (role, objective, context, instructions, examples, output_format)"
          },
          "heading": {
            "type": "str",
            "description": "Section heading as displayed in system message (UPPERCASE with [BRACKETS])"
          },
          "content": {
            "type": "str",
            "description": "Section text content"
          }
        }
      },
      "AgentDefinition": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Agent variable name"
          },
          "display_name": {
            "type": "str",
            "description": "Agent display name"
          },
          "prompt_sections": {
            "type": "list",
            "items": "PromptSection",
            "description": "Agent-specific prompt sections (ordered list). Runtime hook_universal_prompts.py injects universal sections (compliance, guidelines, runtime context) at agent instantiation.",
            "required": false
          },
          "max_consecutive_auto_reply": {
            "type": "int",
            "default": 10
          },
          "auto_tool_mode": {
            "type": "bool",
            "description": "True when the runtime should auto-invoke UI tools for this agent (agent has at least one UI tool entry)."
          },
          "structured_outputs_required": {
            "type": "bool",
            "description": "True when the agent must produce structured outputs (Pydantic model enforced); false otherwise."
          }
        }
      },
      "HandoffRule": {
        "type": "model",
        "fields": {
          "source_agent": {
            "type": "str",
            "description": "Source agent name"
          },
          "target_agent": {
            "type": "str",
            "description": "Target agent name or 'user' or 'terminate'"
          },
          "handoff_type": {
            "type": "literal",
            "values": [
              "condition",
              "after_work"
            ],
            "description": "Type of handoff: 'condition' for immediate evaluation (context or LLM-based), 'after_work' for post-agent-completion evaluation"
          },
          "condition": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Condition text: null for unconditional after_work, expression string with ${var} for context conditions, natural language for LLM conditions"
          },
          "condition_type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Condition evaluation method: 'expression' for context variable expressions (${...}), 'string_llm' for LLM natural language evaluation, null to auto-detect (${} triggers expression, else LLM)"
          },
          "condition_scope": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Evaluation timing for context conditions: 'pre' for pre-reply evaluation (re-checks every turn, ideal for UI interactions), null for default (Post-Reply). NEVER use 'after'."
          },
          "transition_target": {
            "type": "literal",
            "values": [
              "AgentTarget",
              "RevertToUserTarget",
              "TerminateTarget"
            ],
            "description": "Type of transition target"
          }
        },
        "required": [
          "source_agent",
          "target_agent",
          "handoff_type",
          "transition_target"
        ]
      },
      "StructuredModelField": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Field name"
          },
          "type": {
            "type": "str",
            "description": "Field type (str|int|bool|list|union with variants)"
          },
          "description": {
            "type": "str",
            "description": "What this field represents"
          }
        }
      },
      "StructuredModelDefinition": {
        "type": "model",
        "fields": {
          "model_name": {
            "type": "str",
            "description": "Name of the model"
          },
          "fields": {
            "type": "list",
            "items": "StructuredModelField"
          }
        }
      },
      "AgentRegistryEntry": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Agent name"
          },
          "agent_definition": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Model name for this agent, or null if no structured output applies"
          }
        }
      },
      "WorkflowStrategyModule": {
        "type": "model",
        "fields": {
          "module_name": {
            "type": "str",
            "description": "Module name in format 'Module N: Strategic Purpose'"
          },
          "module_index": {
            "type": "int",
            "description": "Zero-based index of this module (0 = Module 1, 1 = Module 2, etc.)"
          },
          "module_description": {
            "type": "str",
            "description": "Strategic description of what happens in this module and why"
          },
          "pattern_id": {
            "type": "int",
            "description": "AG2 pattern ID (1-9) aligned to this module."
          },
          "pattern_name": {
            "type": "str",
            "description": "Human-readable AG2 pattern name aligned to this module."
          },
          "agents_needed": {
            "type": "list",
            "items": "str",
            "description": "Agent names this module requires (guidance list; full specs defined in ModuleAgents)."
          }
        }
      },
      "WorkflowStrategy": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Human-readable workflow name in Title Case With Spaces"
          },
          "workflow_description": {
            "type": "str",
            "description": "Description: When [TRIGGER], workflow [ACTIONS], resulting in [VALUE]"
          },
          "human_in_loop": {
            "type": "bool",
            "description": "Global flag: Does this workflow involve ANY human interaction? (True for chat, False for fully automated background tasks)"
          },
          "pattern": {
            "type": "list",
            "items": "str",
            "description": "List of AG2 orchestration patterns"
          },
          "startup_mode": {
            "type": "literal",
            "values": [
              "UserDriven",
              "AgentDriven",
              "BackendOnly"
            ],
            "description": "How the workflow is initiated: UserDriven (user speaks first), AgentDriven (system/agent speaks first with context), BackendOnly (no UI interaction)"
          },
          "modules": {
            "type": "list",
            "items": "WorkflowStrategyModule",
            "description": "Complete multi-module roadmap. Must contain ALL modules implied by the user request (minimum 3 for complex workflows). Each module must have unique numbered prefix (Module 1:, Module 2:, etc.) in sequential order."
          }
        }
      },
      "CodeFile": {
        "type": "model",
        "fields": {
          "filename": {
            "type": "str",
            "description": "Relative path (using forward slashes) where this file should be written."
          },
          "content": {
            "type": "str",
            "description": "Complete file contents with real newlines. Do not escape code fences or truncate output."
          },
          "installRequirements": {
            "type": "list",
            "items": "str",
            "description": "External packages required for this file. Use [] when none are needed."
          }
        }
      },
      "RequiredContextVariable": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Variable name (snake_case, e.g., 'routing_started', 'current_iteration')"
          },
          "type": {
            "type": "literal",
            "values": [
              "config",
              "data_reference",
              "data_entity",
              "computed",
              "state",
              "external"
            ],
            "description": "Variable type: config (deployment configuration from env vars), data_reference (read existing MongoDB data), data_entity (create new MongoDB data), computed (business logic outputs), state (workflow orchestration state with transitions), external (third-party API data with caching/retry)"
          },
          "trigger_hint": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Simple description of when/how this variable gets set (e.g., 'Set when DownloadAgent completes download', 'User provides city name'). Use null when no natural language description is available."
          },
          "purpose": {
            "type": "str",
            "description": "What this variable tracks and why it's needed (1-2 sentences)"
          }
        }
      },
      "WorkflowUIComponent": {
        "type": "model",
        "fields": {
          "module_name": {
            "type": "str",
            "description": "Module name or label (as surfaced in the Action Plan) where this UI tool appears."
          },
          "agent": {
            "type": "str",
            "description": "PascalCase agent expected to emit the UI tool."
          },
          "tool": {
            "type": "str",
            "description": "Snake_case tool function name associated with the UI surface."
          },
          "label": {
            "type": "str",
            "description": "User-facing label or CTA text so the architect narrative can reference the UI affordance verbatim."
          },
          "component": {
            "type": "str",
            "description": "React component name (PascalCase) used by the UI tool."
          },
          "display": {
            "type": "literal",
            "values": [
              "inline",
              "artifact"
            ],
            "description": "Visual placement hint: 'inline' (conversational, in chat flow) or 'artifact' (separate tray delivery)."
          },
          "ui_pattern": {
            "type": "literal",
            "values": [
              "single_step",
              "two_step_confirmation",
              "multi_step"
            ],
            "description": "Expected interaction cadence: 'single_step' (data collection, agent continues), 'two_step_confirmation' (user reviews and approves/rejects), 'multi_step' (iterative refinement loop)."
          },
          "summary": {
            "type": "str",
            "description": "<=200 char narrative explaining what the user sees or confirms at this component."
          }
        }
      },
      "WorkflowInPack": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Workflow name in PascalCase (e.g., 'ITSupportBot', 'KnowledgeBase')"
          },
          "role": {
            "type": "literal",
            "values": ["primary", "supporting"],
            "description": "Role in the pack: 'primary' is the entry point, 'supporting' workflows are called by primary or other workflows"
          },
          "description": {
            "type": "str",
            "description": "Brief description of what this workflow does (<=100 chars)"
          },
          "pattern_id": {
            "type": "int",
            "description": "AG2 pattern ID (1-9) for this specific workflow"
          },
          "pattern_name": {
            "type": "str",
            "description": "Human-readable pattern name for this workflow"
          }
        }
      },
      "PatternSelection": {
        "type": "model",
        "fields": {
          "is_multi_workflow": {
            "type": "bool",
            "description": "Whether this request requires multiple workflows (pack) or a single workflow"
          },
          "decomposition_reason": {
            "type": "union",
            "variants": ["str", "null"],
            "description": "If is_multi_workflow is true, explains why decomposition is needed. Null for single workflows."
          },
          "pack_name": {
            "type": "str",
            "description": "Name for the workflow pack (Title Case, 2-4 words). Used as pack_name in manifest."
          },
          "workflows": {
            "type": "list",
            "items": "WorkflowInPack",
            "description": "List of workflows in this pack. Single-workflow packs have exactly one item with role='primary'."
          }
        }
      },
      "PatternSelectionOutput": {
        "type": "model",
        "fields": {
          "PatternSelection": {
            "type": "PatternSelection",
            "description": "Pack-aware pattern selection with decomposition decision and per-workflow patterns"
          }
        }
      },
      "WorkflowStrategyOutput": {
        "type": "model",
        "fields": {
          "WorkflowStrategy": {
            "type": "WorkflowStrategy",
            "description": "High-level workflow architecture"
          }
        }
      },
      "MermaidSequenceDiagramOutput": {
        "type": "model",
        "fields": {
          "MermaidSequenceDiagram": {
            "type": "MermaidSequenceDiagram",
            "description": "Diagram payload rendered after the Action Plan is approved."
          },
          "agent_message": {
            "type": "str",
            "description": "Concise invitation (<=140 chars) asking the user to review the diagram."
          }
        }
      },
      "DownloadRequestOutput": {
        "type": "model",
        "fields": {
          "agent_message": {
            "type": "str",
            "description": "Concise message (\u2264140 chars) shown to user in download UI. Example: 'Ready to download your workflow bundle?' Keep action-oriented and brief."
          }
        }
      },
      "ToolsManifestOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "ToolSpec",
            "description": "List of tool entries (mirrors tools.json format)"
          },
          "lifecycle_tools": {
            "type": "list",
            "items": "LifecycleToolSpec",
            "description": "List of lifecycle tool entries (optional, can be empty array or omitted). Matches the current tools.json structure with explicit trigger + agent metadata."
          }
        }
      },
      "RuntimeAgentsOutput": {
        "type": "model",
        "fields": {
          "agents": {
            "type": "list",
            "items": "AgentDefinition"
          }
        }
      },
      "UIToolsFilesOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "CodeFile",
            "description": "Ordered list of UI tool files (Python async functions + React components) to write to disk."
          }
        }
      },
      "AgentToolsFilesOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "CodeFile",
            "description": "Ordered list of backend agent tool implementation files to write to disk."
          }
        }
      },
      "ContextVariablesPlanOutput": {
        "type": "model",
        "fields": {
          "ContextVariablesPlan": {
            "type": "ContextVariablesPlan",
            "description": "Complete plan with definitions dict (all variables) and agents dict (exposure mappings)."
          }
        }
      },
      "HandoffRulesOutput": {
        "type": "model",
        "fields": {
          "handoff_rules": {
            "type": "list",
            "items": "HandoffRule"
          }
        }
      },
      "StructuredModelsOutput": {
        "type": "model",
        "fields": {
          "models": {
            "type": "list",
            "items": "StructuredModelDefinition",
            "description": "Data models to capture"
          },
          "registry": {
            "type": "list",
            "items": "AgentRegistryEntry"
          }
        }
      },
      "OrchestrationConfigOutput": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Workflow identifier"
          },
          "max_turns": {
            "type": "int",
            "description": "Maximum conversation turns"
          },
          "human_in_the_loop": {
            "type": "bool",
            "description": "Whether human interaction is required"
          },
          "startup_mode": {
            "type": "literal",
            "values": [
              "AgentDriven",
              "UserDriven",
              "BackendOnly"
            ]
          },
          "orchestration_pattern": {
            "type": "str",
            "default": "DefaultPattern"
          },
          "initial_message_to_user": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Message shown to user (UserDriven only)"
          },
          "initial_message": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Initial workflow message (AgentDriven/BackendOnly)"
          },
          "initial_agent": {
            "type": "str",
            "description": "Name of the first agent that receives control when the workflow starts (matches AG2 pattern 'initial_agent' parameter)."
          },
          "visual_agents": {
            "type": "list",
            "items": "str",
            "description": "Agents permitted to render UI/text to the user (mirrors ui_config.json visual_agents list)."
          }
        }
      },
      "HookFilesOutput": {
        "type": "model",
        "fields": {
          "hook_files": {
            "type": "list",
            "items": "HookFile",
            "description": "Array of hook file objects (can be empty [] if no custom hooks needed)"
          }
        }
      },
      "LifecycleRequirements": {
        "type": "model",
        "fields": {
          "before_chat": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Name of the lifecycle hook that must run before the chat session starts, or null when no initialization is required."
          },
          "after_chat": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Name of the lifecycle hook that runs after the workflow completes, or null when no teardown is needed."
          }
        }
      },
      "StateArchitecture": {
        "type": "model",
        "fields": {
          "global_context_variables": {
            "type": "list",
            "items": "RequiredContextVariable",
            "description": "Workflow-wide context variables that downstream agents must honor"
          },
          "lifecycle_requirements": {
            "type": "union",
            "variants": [
              "LifecycleRequirements",
              "null"
            ],
            "description": "Lifecycle hooks required for the workflow (before_chat, after_chat). Use null when no hooks are needed."
          },
          "workflow_dependencies": {
            "type": "list",
            "items": "str",
            "description": "Dependencies on other workflows"
          }
        },
        "required": [
          "global_context_variables",
          "lifecycle_requirements",
          "workflow_dependencies"
        ]
      },
      "UXArchitecture": {
        "type": "model",
        "fields": {
          "ui_requirements": {
            "type": "list",
            "items": "WorkflowUIComponent",
            "description": "Module-aligned summary of expected UI interactions"
          }
        }
      },
      "AgentRoster": {
        "type": "model",
        "fields": {
          "agents": {
            "type": "list",
            "items": "WorkflowAgent",
            "description": "Ordered list of agent specifications"
          }
        }
      },
      "ToolPlanning": {
        "type": "model",
        "fields": {
          "agent_tools": {
            "type": "list",
            "items": "PlannedAgentTool",
            "description": "List of backend/logic tools required by agents (excludes UI tools defined in UXArchitecture)."
          },
          "lifecycle_tools": {
            "type": "list",
            "items": "LifecycleTool",
            "description": "Lifecycle operation tools"
          },
          "system_hooks": {
            "type": "list",
            "items": "SystemHook",
            "description": "System hooks required"
          }
        }
      },
      "StateArchitectureOutput": {
        "type": "model",
        "fields": {
          "StateArchitecture": {
            "type": "StateArchitecture",
            "description": "State & Data Architecture"
          }
        }
      },
      "UXArchitectureOutput": {
        "type": "model",
        "fields": {
          "UXArchitecture": {
            "type": "UXArchitecture",
            "description": "User Experience Architecture"
          }
        }
      },
      "AgentRosterOutput": {
        "type": "model",
        "fields": {
          "AgentRoster": {
            "type": "AgentRoster",
            "description": "Agent Roster"
          }
        }
      },
      "ToolPlanningOutput": {
        "type": "model",
        "fields": {
          "ToolPlanning": {
            "type": "ToolPlanning",
            "description": "Tool & Hook Planning"
          }
        }
      },
      "PlannedAgentTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Tool function name (snake_case)."
          },
          "agent": {
            "type": "str",
            "description": "Name of the agent that uses this tool."
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service (PascalCase) or null."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of tool functionality."
          },
          "interaction_mode": {
            "type": "literal",
            "values": [
              "inline",
              "artifact",
              "none"
            ],
            "description": "Interaction surface: inline (chat), artifact (panel), none (backend)."
          }
        }
      },
      "PackWorkflowEntry": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Workflow name (PascalCase)"
          },
          "description": {
            "type": "str",
            "description": "Brief description of the workflow"
          },
          "role": {
            "type": "literal",
            "values": ["primary", "supporting"],
            "description": "Role in the pack"
          },
          "startup_mode": {
            "type": "literal",
            "values": ["UserDriven", "AgentDriven", "BackendOnly"],
            "description": "How this workflow starts"
          }
        }
      },
      "PackManifest": {
        "type": "model",
        "fields": {
          "pack_name": {
            "type": "str",
            "description": "Name of the workflow pack (Title Case)"
          },
          "pack_description": {
            "type": "str",
            "description": "Brief description of what the pack does"
          },
          "version": {
            "type": "str",
            "description": "Semantic version (e.g., '1.0.0')"
          },
          "entry_point": {
            "type": "str",
            "description": "Name of the primary workflow (entry point)"
          },
          "workflows": {
            "type": "list",
            "items": "PackWorkflowEntry",
            "description": "List of workflows in this pack"
          },
          "ui_config": {
            "type": "PackUIConfig",
            "description": "UI configuration for workflow transitions"
          }
        }
      },
      "PackUIConfig": {
        "type": "model",
        "fields": {
          "show_workflow_transitions": {
            "type": "bool",
            "description": "Whether to show workflow transition messages to user"
          },
          "transition_style": {
            "type": "literal",
            "values": ["dropdown", "inline", "hidden"],
            "description": "How to display workflow transitions: dropdown (visual stack), inline (text message), hidden (seamless)"
          }
        }
      },
      "WorkflowGraphNode": {
        "type": "model",
        "fields": {
          "id": {
            "type": "str",
            "description": "Workflow name (matches workflow folder name)"
          },
          "type": {
            "type": "literal",
            "values": ["primary", "supporting"],
            "description": "Node type in the graph"
          }
        }
      },
      "WorkflowGraphEdge": {
        "type": "model",
        "fields": {
          "from": {
            "type": "str",
            "description": "Source workflow name"
          },
          "to": {
            "type": "str",
            "description": "Target workflow name"
          },
          "trigger": {
            "type": "literal",
            "values": ["context_variable", "completion", "explicit_call"],
            "description": "What triggers this edge: context_variable (DB watch), completion (workflow ends), explicit_call (agent tool)"
          },
          "condition": {
            "type": "union",
            "variants": ["str", "null"],
            "description": "Condition expression for context_variable triggers (e.g., 'needs_kb_search == true')"
          },
          "description": {
            "type": "str",
            "description": "Human-readable description of when this transition happens"
          },
          "sync": {
            "type": "bool",
            "description": "Whether to wait for target workflow to complete (true) or fire-and-forget (false)"
          }
        }
      },
      "WorkflowGraph": {
        "type": "model",
        "fields": {
          "nodes": {
            "type": "list",
            "items": "WorkflowGraphNode",
            "description": "All workflows in the pack as graph nodes"
          },
          "edges": {
            "type": "list",
            "items": "WorkflowGraphEdge",
            "description": "Connections between workflows"
          }
        }
      },
      "SharedContextVariable": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Variable name (snake_case)"
          },
          "type": {
            "type": "literal",
            "values": ["state", "config", "data_reference", "data_entity", "computed", "external", "content", "collection"],
            "description": "Variable type from the 6+2 type taxonomy"
          },
          "owner": {
            "type": "str",
            "description": "Workflow that creates/owns this variable"
          },
          "consumers": {
            "type": "list",
            "items": "str",
            "description": "Workflows that read this variable"
          },
          "description": {
            "type": "str",
            "description": "What this variable represents"
          }
        }
      },
      "SharedContext": {
        "type": "model",
        "fields": {
          "variables": {
            "type": "list",
            "items": "SharedContextVariable",
            "description": "Variables shared across workflows"
          },
          "refresh_strategy": {
            "type": "literal",
            "values": ["db_watch", "polling", "explicit"],
            "description": "How consuming workflows detect changes"
          },
          "db_collection": {
            "type": "str",
            "description": "MongoDB collection name for shared context"
          }
        }
      },
      "PackMetadataOutput": {
        "type": "model",
        "description": "Combined output for all pack metadata files",
        "fields": {
          "PackMetadata": {
            "type": "model",
            "fields": {
              "manifest": {
                "type": "PackManifest",
                "description": "Pack manifest for _pack/manifest.json"
              },
              "workflow_graph": {
                "type": "WorkflowGraph",
                "description": "Workflow dependency graph for _pack/workflow_graph.json"
              },
              "shared_context": {
                "type": "SharedContext",
                "description": "Shared context configuration for _pack/shared_context.json"
              }
            }
          }
        }
      }
    },
    "registry": {
      "InterviewAgent": null,
      "PatternAgent": "PatternSelectionOutput",
      "WorkflowStrategyAgent": "WorkflowStrategyOutput",
      "StateArchitectAgent": "StateArchitectureOutput",
      "UXArchitectAgent": "UXArchitectureOutput",
      "AgentRosterAgent": "AgentRosterOutput",
      "ToolPlanningAgent": "ToolPlanningOutput",
      "ProjectOverviewAgent": "MermaidSequenceDiagramOutput",
      "ContextVariablesAgent": "ContextVariablesPlanOutput",
      "ToolsManagerAgent": "ToolsManifestOutput",
      "UIFileGenerator": "UIToolsFilesOutput",
      "AgentToolsFileGenerator": "AgentToolsFilesOutput",
      "HookAgent": "HookFilesOutput",
      "AgentsAgent": "RuntimeAgentsOutput",
      "OrchestratorAgent": "OrchestrationConfigOutput",
      "HandoffsAgent": "HandoffRulesOutput",
      "StructuredOutputsAgent": "StructuredModelsOutput",
      "PackMetadataAgent": "PackMetadataOutput",
      "DownloadAgent": "DownloadRequestOutput"
    }
  }
}
