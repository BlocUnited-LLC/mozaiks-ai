# ==============================================================================
# FILE: Generator/Agents.py  
# DESCRIPTION: Agent factory for the Generator workflow
# ==============================================================================
import asyncio
import sys
import os
from pathlib import Path

# Add the core directory to the Python path
core_path = Path(__file__).parent.parent.parent / "core"
sys.path.insert(0, str(core_path))

from autogen import ConversableAgent
from .StructuredOutputs import get_llm
import logging

logger = logging.getLogger(__name__)

async def define_agents(base_llm_config):
    """Define agents with unified transport channel and dynamic hooks"""
    
    logger.info("üèóÔ∏è [GENERATOR] Creating agents...")
    import time
    start_time = time.time()

    # Get structured LLM configs for each agent
    logger.debug("üîß [GENERATOR] Loading LLM configs...")
    _, llm_cfg_context = await get_llm("ContextVariablesAgent")
    _, llm_cfg_agents = await get_llm("AgentsAgent")
    _, llm_cfg_handoffs = await get_llm("HandoffsAgent")
    _, llm_cfg_hooks = await get_llm("HooksAgent")
    _, llm_cfg_orch = await get_llm("OrchestratorAgent")
    _, llm_cfg_apikey = await get_llm("APIKeyAgent")
    _, llm_cfg_feedback = await get_llm("UserFeedbackAgent")
    logger.debug("‚úÖ [GENERATOR] LLM configs loaded")
    
    agents = {}
    
    # NOTE: UserProxyAgent is now auto-generated by groupchat_manager.py
    # based on workflow.json human_in_the_loop flag. No need to create it here.
    
    # Agents Agent - Now the first agent to run
    logger.debug("üîß [GENERATOR] Creating AgentsAgent...")
    agents["AgentsAgent"] = ConversableAgent(
        name="AgentsAgent", 
        system_message="""You are the AgentsAgent, responsible for designing and defining agents for AG2 workflows. You are the FIRST agent in the workflow.

IMMEDIATE TASK:
Based on the concept overview provided in the context variables, immediately analyze what types of agents will be needed and output structured agent definitions in JSON format.

OUTPUT FORMAT:
Your response must be valid JSON following this exact schema:

{
  "agent_list": [
    {
      "name": "agent_variable_name",
      "display_name": "Agent Display Name", 
      "agent_type": "ConversableAgent",
      "system_message": "Detailed instructions defining agent's exact role and tasks",
      "human_input_mode": "NEVER",
      "max_consecutive_auto_reply": 10
    }
  ]
}

ANALYSIS APPROACH:
1. Read and understand the concept overview from context variables
2. Identify the core domain, functionality, and user needs described
3. Determine what types of agents would be needed to build this application
4. Consider agents for: user interaction, domain expertise, data processing, coordination, validation, content generation

EXAMPLE OUTPUT (for any domain):
{
  "agent_list": [
    {
      "name": "domain_expert_agent",
      "display_name": "Domain Expert",
      "agent_type": "ConversableAgent", 
      "system_message": "You are a domain expert who provides specialized knowledge and guidance based on the application requirements and user needs.",
      "human_input_mode": "NEVER",
      "max_consecutive_auto_reply": 10
    },
    {
      "name": "user_interface_agent", 
      "display_name": "User Interface Manager",
      "agent_type": "ConversableAgent",
      "system_message": "You manage user interactions, handle input validation, and coordinate responses to provide a smooth user experience.",
      "human_input_mode": "NEVER", 
      "max_consecutive_auto_reply": 10
    }
  ]
}

YOUR TASK:
Analyze the concept overview in the context variables and immediately output the structured JSON with all necessary agent definitions for this specific application domain.""",
        llm_config=llm_cfg_agents,
        human_input_mode="NEVER",
        max_consecutive_auto_reply=5
    )
    
    # Context Variables Agent - Now runs AFTER AgentsAgent
    logger.debug("üîß [GENERATOR] Creating ContextVariablesAgent...")
    agents["ContextVariablesAgent"] = ConversableAgent(
        name="ContextVariablesAgent",
        system_message="""You are the ContextVariablesAgent. Your job is to analyze the concept overview AND the agent definitions created by AgentsAgent, then output structured context variables in JSON format.

Based on:
1. The concept overview provided in the context variables
2. The agent definitions that were just created by AgentsAgent
3. What context variables those agents will need to function properly

OUTPUT FORMAT:
Your response must be valid JSON following this exact schema:

{
  "context_variables": [
    {
      "name": "variable_name",
      "extraction_code": "concept_data.get('KeyName', '')",
      "description": "Description of what this variable represents", 
      "default_value": "''"
    }
  ]
}

ANALYSIS APPROACH:
1. Examine the concept overview to understand the application domain and requirements
2. Review the agent definitions to understand what data they'll need
3. Create context variables that extract relevant information from the concept data
4. Consider variables for: project metadata, domain-specific data, user requirements, technical specifications, business requirements

EXAMPLE OUTPUT (generic for any domain):
{
  "context_variables": [
    {
      "name": "project_title",
      "extraction_code": "concept_data.get('ProjectTitle', '')",
      "description": "Main project title from concept overview",
      "default_value": "''"
    },
    {
      "name": "target_audience", 
      "extraction_code": "concept_data.get('TargetAudience', '')",
      "description": "Primary user demographic for the application",
      "default_value": "'general users'"
    },
    {
      "name": "domain_specific_data",
      "extraction_code": "concept_data.get('DomainData', {})",
      "description": "Domain-specific information that the agents will need to function",
      "default_value": "{}"
    }
  ]
}

YOUR TASK:
Analyze the concept overview data AND consider what context variables the previously defined agents will need, then immediately output the structured JSON with all necessary context variables for this specific application domain.""",
        llm_config=llm_cfg_context,
        human_input_mode="NEVER",
        max_consecutive_auto_reply=5
    )

    # Handoffs Agent
    logger.debug("üîß [GENERATOR] Creating HandoffsAgent...")
    agents["HandoffsAgent"] = ConversableAgent(
        name="HandoffsAgent", 
        system_message="""You are the HandoffsAgent. Your job is to output only the structured YAML defining handoff rules between agents.

OUTPUT FORMAT:
Your response must be valid YAML and follow this exact schema‚Äîdo not include any narrative, explanations, or markdown:

handoffs:
  - from: <AgentA>
    to: <AgentB>
    condition: "<Explicit condition when handoff should occur>"
    type: <llm_triggered|task_completed>
# repeat for each handoff

YOUR TASK:
1. Identify every transition in the agent workflow.
2. Define each handoff with source agent, target agent, condition, and type.
3. Output only valid YAML for the handoffs section.""",
        llm_config=llm_cfg_handoffs,
        human_input_mode="NEVER",
        max_consecutive_auto_reply=5
    )

    # Hooks Agent  
    logger.debug("üîß [GENERATOR] Creating HooksAgent...")
    agents["HooksAgent"] = ConversableAgent(
        name="HooksAgent",
        system_message="""You are the HooksAgent. Your task is to output only the structured YAML defining custom hooks for this workflow.

OUTPUT FORMAT:
Your response must be valid YAML and follow this exact schema‚Äîdo not include any narrative, explanations, or markdown:

hooks:
  - name: <hook_name>
    type: <process_message_before_send|process_message_after_receive|update_agent_state>
    agents: [<AgentName>]
    code: |
      <Hook function code>
# repeat for each hook

YOUR TASK:
1. Identify required hook functions for logging, validation, or state updates.
2. For each hook, specify name, type, applicable agents, and code.
3. Output only valid YAML for the hooks section.""",
        llm_config=llm_cfg_hooks,
        human_input_mode="NEVER",
        max_consecutive_auto_reply=5
    )

    # Orchestrator Agent
    logger.debug("üîß [GENERATOR] Creating OrchestratorAgent...")
    agents["OrchestratorAgent"] = ConversableAgent(
        name="OrchestratorAgent",
        system_message="""You are the OrchestratorAgent. Your task is to output only the structured YAML defining the orchestration settings for this workflow.

OUTPUT FORMAT:
Your response must be valid YAML and follow this exact schema‚Äîdo not include any narrative, explanations, or markdown:

orchestration:
  workflow_name: "<Descriptive Workflow Name>"
  description: "<Concise summary of the workflow's purpose>"
  initial_agent: <AgentName>
  max_rounds: <integer>

YOUR TASK:
1. Determine the workflow's name, description, initial agent, and max rounds.
2. Output only valid YAML for the orchestration section.""",
        llm_config=llm_cfg_orch,
        human_input_mode="NEVER",
        max_consecutive_auto_reply=5
    )

    # API Key Agent
    logger.debug("üîß [GENERATOR] Creating APIKeyAgent...")
    agents["APIKeyAgent"] = ConversableAgent(
        name="APIKeyAgent",
        system_message="""You are the APIKeyAgent. Your responsibilities:

- Analyze the workflow's required external APIs.
- For each required service, invoke the tool `api_manager.store_api_key` with arguments:
  - service: <ServiceName>
  - description: <Explanation of why this key is needed>
- Ensure the tool call collects and securely stores the API key.
- Do NOT output any YAML; rely solely on the tool calls to gather credentials.""",
        llm_config=llm_cfg_apikey,
        human_input_mode="NEVER",
        max_consecutive_auto_reply=5
    )

    # User Feedback Agent
    logger.debug("üîß [GENERATOR] Creating UserFeedbackAgent...")
    agents["UserFeedbackAgent"] = ConversableAgent(
        name="UserFeedbackAgent",
        system_message="""You are the UserFeedbackAgent. Your responsibilities:

- Collect the structured YAML snippets generated by ContextVariablesAgent, AgentsAgent, HandoffsAgent, HooksAgent, OrchestratorAgent, and APIKeyAgent.
- Assemble them into the final workflow manifest stored as `workflow.yaml` in context variables.
- When the user requests download, invoke the tool `file_manager.handle_download` with:
  - data: { type: 'download', fileId: <id>, filename: 'workflow.yaml' }
- Do NOT output YAML directly; rely on tool calls to deliver files.""",
        llm_config=llm_cfg_feedback,
        human_input_mode="ALWAYS",
        max_consecutive_auto_reply=5
    )

    # Log completion
    agent_count = len(agents)
    duration = time.time() - start_time
    logger.info(f"‚úÖ [GENERATOR] Created {agent_count} agents in {duration:.2f}s")
    logger.debug(f"üîç [GENERATOR] Agent names: {list(agents.keys())}")

    return agents
