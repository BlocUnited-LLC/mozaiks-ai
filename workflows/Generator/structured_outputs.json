{
  "structured_outputs": {
    "models": {
      "AgentTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Tool function name (snake_case). The actual callable that the agent invokes."
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service this tool interacts with (PascalCase). Examples: 'Stripe', 'Slack', 'OpenAI', 'GitHub'. Use null for tools that don't require external API calls."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of what this tool does and why the agent needs it (<=140 chars)."
          },
          "interaction_mode": {
            "type": "literal",
            "values": [
              "inline",
              "artifact",
              "none"
            ],
            "description": "Interaction surface for this tool: inline (chat-embedded), artifact (side panel or tray), none (backend-only or silent)."
          }
        }
      },
      "LifecycleTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Lifecycle tool function name (snake_case). The actual callable that executes the lifecycle operation."
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service this lifecycle tool interacts with (PascalCase). Use null for internal-only operations."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of what this lifecycle operation does (<=140 chars)."
          },
          "trigger": {
            "type": "str",
            "allowed_values": [
              "before_agent",
              "after_agent"
            ],
            "description": "When this lifecycle operation executes relative to the agent's main work."
          }
        }
      },
      "SystemHook": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "System hook identifier (snake_case). Examples: 'update_agent_state', 'process_message_before_send', 'process_last_received_message', 'process_all_messages_before_reply'."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of why this agent needs this specific system hook (<=140 chars)."
          }
        }
      },
      "WorkflowAgent": {
        "type": "model",
        "fields": {
          "agent_name": {
            "type": "str",
            "description": "Agent identifier (unique within the workflow)"
          },
          "agent_type": {
            "type": "str",
            "allowed_values": [
              "router",
              "worker",
              "evaluator",
              "orchestrator",
              "intake",
              "generator"
            ],
            "description": "Architectural role of the agent. router=control flow; worker=execution; evaluator=QA/decision; orchestrator=sub-team lead; intake=user-facing entry; generator=single-shot content generator."
          },
          "objective": {
            "type": "str",
            "description": "Short human-readable description of the agent's responsibilities (displayed in the UI)."
          },
          "agent_tools": {
            "type": "list",
            "items": "AgentTool",
            "description": "Agent-specific tools this agent can call. Each tool specifies name, integration, and purpose. Use [] when no agent tools are required."
          },
          "lifecycle_tools": {
            "type": "list",
            "items": "LifecycleTool",
            "description": "Lifecycle operation tools this agent executes. Each tool specifies name, integration, purpose, and trigger timing. Use [] when no lifecycle tools are required."
          },
          "system_hooks": {
            "type": "list",
            "items": "SystemHook",
            "description": "System hooks this agent uses for runtime behavior modification. Each hook specifies name and purpose. Use [] when no system hooks are required."
          },
          "human_interaction": {
            "type": "str",
            "allowed_values": [
              "none",
              "context",
              "approval",
              "feedback",
              "single"
            ],
            "description": "Human involvement mode for THIS SPECIFIC AGENT. none = fully automated execution; context = conversational data collection or clarification; approval = explicit sign-off/decision gate; feedback = non-UI iterative refinement; single = one-shot invocation."
          },
          "generation_mode": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Generation mode for generator agents: allowed values text, image, video, audio. Use null for non-generator agents."
          },
          "max_consecutive_auto_reply": {
            "type": "int",
            "description": "Maximum number of consecutive auto-replies allowed for this agent. Calibrate from human_interaction: none=30 (high autonomy), context=20 (conversational intake), approval/feedback=5 (low autonomy), single=1 (one-shot)."
          }
        }
      },
      "MermaidSequenceDiagram": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Workflow name this diagram represents"
          },
          "mermaid_diagram": {
            "type": "str",
            "description": "Complete Mermaid sequence diagram text, beginning with 'sequenceDiagram'. Must include required blank line after participant declarations."
          },
          "legend": {
            "type": "list",
            "items": "str",
            "description": "Optional module legend entries (M1: Module Name). Provide [] when no legend is required."
          }
        }
      },
      "DerivedTriggerMatch": {
        "type": "model",
        "fields": {
          "equals": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Exact string match required for the trigger (agent_text only)."
          },
          "contains": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Substring match evaluated against emitted agent text (agent_text only)."
          },
          "regex": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Regular expression applied to emitted agent text (agent_text only)."
          }
        }
      },
      "DerivedTrigger": {
        "type": "model",
        "fields": {
          "type": {
            "type": "literal",
            "values": [
              "agent_text",
              "ui_response"
            ],
            "description": "Trigger mode: agent_text (passive detection) or ui_response (active UI tool response)."
          },
          "agent": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Agent whose output is monitored (required when type=agent_text)."
          },
          "match": {
            "type": "union",
            "variants": [
              "DerivedTriggerMatch",
              "null"
            ],
            "description": "Match conditions for agent_text triggers. Must be omitted for ui_response triggers."
          },
          "tool": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Snake_case tool name responsible for updating the variable (required when type=ui_response)."
          },
          "response_key": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Key in the UI tool response payload whose value seeds the state variable (required when type=ui_response)."
          },
          "ui_hidden": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Whether to hide the agent's text output from the user UI (agent_text triggers only). True = hide token (e.g. NEXT), False = show message."
          }
        }
      },
      "ContextVariableSource": {
        "type": "model",
        "fields": {
          "type": {
            "type": "literal",
            "values": [
              "config",
              "data_reference",
              "data_entity",
              "computed",
              "state",
              "external"
            ],
            "description": "Source classification: config (deployment configuration from env vars), data_reference (read existing MongoDB data), data_entity (create new MongoDB data), computed (business logic outputs), state (workflow orchestration state with transitions), external (third-party API data with caching/retry)."
          },
          "env_var": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Environment variable name (config sources only, UPPER_SNAKE_CASE)."
          },
          "default": {
            "type": "union",
            "variants": [
              "str",
              "int",
              "bool",
              "null"
            ],
            "description": "Fallback value when the source is unavailable (config, computed, state sources)."
          },
          "required": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Whether this config variable is required (config sources only)."
          },
          "database_name": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Mongo database name (data_reference and data_entity sources only)."
          },
          "collection": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Mongo collection name (data_reference and data_entity sources only)."
          },
          "query_template": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "MongoDB query template with ${var} placeholders (data_reference sources only)."
          },
          "fields": {
            "type": "union",
            "variants": [
              "list",
              "null"
            ],
            "description": "List of fields to extract from query result (data_reference sources only)."
          },
          "refresh_strategy": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "When to refresh data: 'once' (cache indefinitely), 'per_module' (refresh each module), 'on_demand' (refresh when requested). Data_reference sources only."
          },
          "schema": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "JSON schema for the entity structure (data_entity sources only)."
          },
          "indexes": {
            "type": "union",
            "variants": [
              "list",
              "null"
            ],
            "description": "MongoDB index definitions for this entity (data_entity sources only)."
          },
          "write_strategy": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "When to persist entity: 'immediate' (on creation), 'on_module_transition', 'on_workflow_end'. Data_entity sources only."
          },
          "search_by": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Field used to locate/update the entity (data_entity sources only)."
          },
          "computation": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Description of the computation logic (computed sources only)."
          },
          "inputs": {
            "type": "union",
            "variants": [
              "list",
              "null"
            ],
            "description": "List of input variable names required for computation (computed sources only)."
          },
          "output_type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Expected output data type (computed sources only)."
          },
          "persist_to": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "Optional MongoDB persistence config (computed sources only)."
          },
          "transitions": {
            "type": "union",
            "variants": [
              "list",
              "null"
            ],
            "description": "State transition definitions with triggers (state sources only)."
          },
          "persist": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Whether to persist state across sessions (state sources only)."
          },
          "service": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service name (external sources only, e.g., 'Stripe', 'OpenAI')."
          },
          "operation": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "API operation or endpoint (external sources only)."
          },
          "params": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "API request parameters with ${var} placeholders (external sources only)."
          },
          "auth": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "Authentication configuration (external sources only)."
          },
          "cache": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "Cache configuration with TTL (external sources only)."
          },
          "retry": {
            "type": "union",
            "variants": [
              "dict",
              "null"
            ],
            "description": "Retry policy for failed requests (external sources only)."
          },
          "triggers": {
            "type": "list",
            "items": "DerivedTrigger",
            "description": "Trigger definitions for state sources with transitions. Use [] for other types.",
            "default": []
          }
        }
      },
      "ContextVariableDefinitionEntry": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Unique snake_case variable name."
          },
          "type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Canonical data type for downstream casting (string|integer|boolean etc.)."
          },
          "description": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Human readable description explaining the variable purpose."
          },
          "source": {
            "type": "ContextVariableSource",
            "description": "Source metadata describing where the value originates."
          }
        }
      },
      "ContextVariableAgentExposure": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Agent name receiving these variables."
          },
          "variables": {
            "type": "list",
            "items": "str",
            "description": "Variables exposed to the agent (empty list permitted).",
            "default": []
          }
        }
      },
      "ContextVariablesPlan": {
        "type": "model",
        "fields": {
          "definitions": {
            "type": "list",
            "items": "ContextVariableDefinitionEntry",
            "description": "Ordered list of context variable definitions (each entry includes name, type, description, and source metadata)."
          },
          "agents": {
            "type": "list",
            "items": "ContextVariableAgentExposure",
            "description": "Agent exposure entries describing which variables are visible to each agent."
          }
        }
      },
      "UIConfig": {
        "type": "model",
        "fields": {
          "component": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "React component name (UI_Tool only)"
          },
          "display": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Primary rendering hint for runtime events: inline or artifact."
          },
          "label": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Primary call-to-action or heading copy surfaced by the UI component."
          },
          "description": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Helper copy that must be rendered verbatim in the UI tool."
          }
        }
      },
      "ToolSpec": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Owning agent (or primary agent)"
          },
          "file": {
            "type": "str",
            "description": "Python module file name"
          },
          "function": {
            "type": "str",
            "description": "Async function inside the file"
          },
          "description": {
            "type": "str",
            "description": "Tool purpose (<=140 chars, no secrets)"
          },
          "tool_type": {
            "type": "literal",
            "values": [
              "UI_Tool",
              "Agent_Tool"
            ],
            "description": "Tool type"
          },
          "auto_invoke": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Controls whether tool is automatically invoked when agent produces structured output. Default: true for UI_Tool, false for Agent_Tool. Set true for Agent_Tools whose structured output must be stored in context for downstream agents to access. Omit (null) to use defaults."
          },
          "ui": {
            "type": "UIConfig",
            "description": "UI metadata (nulls for Agent_Tool)"
          }
        }
      },
      "UIToolFile": {
        "type": "model",
        "fields": {
          "tool_name": {
            "type": "str",
            "description": "Tool function name (snake_case, basename only, no path prefix)"
          },
          "py_content": {
            "type": "str",
            "description": "Complete Python async function source code as string (no placeholders)"
          },
          "js_content": {
            "type": "str",
            "description": "Complete React component source code as string (no placeholders)"
          }
        }
      },
      "AgentToolFile": {
        "type": "model",
        "fields": {
          "tool_name": {
            "type": "str",
            "description": "Tool function name (snake_case, basename only, no path prefix)"
          },
          "py_content": {
            "type": "str",
            "description": "Complete Python function source code as string (no placeholders, can be sync or async)"
          }
        }
      },
      "HookFile": {
        "type": "model",
        "fields": {
          "filename": {
            "type": "str",
            "description": "Hook file name (e.g., 'validate_budget.py', 'audit_decisions.py')"
          },
          "hook_type": {
            "type": "literal",
            "values": [
              "before_chat",
              "after_chat",
              "update_agent_state"
            ],
            "description": "Lifecycle hook type"
          },
          "py_content": {
            "type": "str",
            "description": "Complete Python code for hook function"
          }
        }
      },
      "PromptSectionContent": {
        "type": "model",
        "description": "Content container for a single prompt section (heading + text)",
        "fields": {
          "heading": {
            "type": "str",
            "description": "Section heading as displayed in system message (UPPERCASE with [BRACKETS])"
          },
          "content": {
            "type": "str",
            "description": "Section text content"
          }
        }
      },
      "PromptSections": {
        "type": "model",
        "description": "Standardized 6-section prompt structure for runtime agents: role, objective, context, instructions, examples, output_format. Universal sections (compliance, guidelines, runtime context) are hook-injected at runtime via hook_universal_prompts.py.",
        "fields": {
          "role": {
            "type": "PromptSectionContent",
            "description": "Agent identity (single sentence). Heading: [ROLE]"
          },
          "objective": {
            "type": "PromptSectionContent",
            "description": "Key deliverables (2-4 bullets). Heading: [OBJECTIVE]"
          },
          "context": {
            "type": "PromptSectionContent",
            "description": "Inputs, outputs, workflow position, exposed context variables. Heading: [CONTEXT]"
          },
          "instructions": {
            "type": "PromptSectionContent",
            "description": "Step-by-step algorithm with embedded subsections (context variables, coordination tokens, tools). Heading: [INSTRUCTIONS]"
          },
          "examples": {
            "type": "PromptSectionContent",
            "description": "Concrete usage examples showing expected agent behavior. Include input/output examples and edge cases. Heading: [EXAMPLES]",
            "required": false
          },
          "output_format": {
            "type": "PromptSectionContent",
            "description": "Expected schema and examples. Heading: [OUTPUT FORMAT]"
          }
        },
        "required": [
          "role",
          "objective",
          "context",
          "instructions",
          "output_format"
        ]
      },
      "AgentDefinition": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Agent variable name"
          },
          "display_name": {
            "type": "str",
            "description": "Agent display name"
          },
          "prompt_sections": {
            "type": "PromptSections",
            "description": "Agent-specific prompt sections (6-field structure). Runtime hook_universal_prompts.py injects universal sections (compliance, guidelines, runtime context) at agent instantiation. Factory._compose_prompt_sections() converts this to system_message string for ConversableAgent.",
            "required": false
          },
          "max_consecutive_auto_reply": {
            "type": "int",
            "default": 10
          },
          "auto_tool_mode": {
            "type": "bool",
            "description": "True when the runtime should auto-invoke UI tools for this agent (agent has at least one UI tool entry)."
          },
          "structured_outputs_required": {
            "type": "bool",
            "description": "True when the agent must produce structured outputs (Pydantic model enforced); false otherwise."
          }
        }
      },
      "HandoffRule": {
        "type": "model",
        "fields": {
          "source_agent": {
            "type": "str",
            "description": "Source agent name"
          },
          "target_agent": {
            "type": "str",
            "description": "Target agent name or 'user' or 'terminate'"
          },
          "handoff_type": {
            "type": "literal",
            "values": [
              "condition",
              "after_work"
            ],
            "description": "Type of handoff: 'condition' for immediate evaluation (context or LLM-based), 'after_work' for post-agent-completion evaluation"
          },
          "condition": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Condition text: null for unconditional after_work, expression string with ${var} for context conditions, natural language for LLM conditions"
          },
          "condition_type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Condition evaluation method: 'expression' for context variable expressions (${...}), 'string_llm' for LLM natural language evaluation, null to auto-detect (${} triggers expression, else LLM)"
          },
          "condition_scope": {
            "type": "union",
            "variants": [
              "literal",
              "null"
            ],
            "values": [
              "pre"
            ],
            "description": "Evaluation timing for context conditions: 'pre' for pre-reply evaluation (re-checks every turn, ideal for UI interactions), null for default (Post-Reply). NEVER use 'after'."
          },
          "transition_target": {
            "type": "literal",
            "values": [
              "AgentTarget",
              "RevertToUserTarget",
              "TerminateTarget"
            ],
            "description": "Type of transition target"
          }
        },
        "required": [
          "source_agent",
          "target_agent",
          "handoff_type",
          "transition_target"
        ]
      },
      "StructuredModelField": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Field name"
          },
          "type": {
            "type": "str",
            "description": "Field type (str|int|bool|list|union with variants)"
          },
          "description": {
            "type": "str",
            "description": "What this field represents"
          }
        }
      },
      "StructuredModelDefinition": {
        "type": "model",
        "fields": {
          "model_name": {
            "type": "str",
            "description": "Name of the model"
          },
          "fields": {
            "type": "list",
            "items": "StructuredModelField"
          }
        }
      },
      "AgentRegistryEntry": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Agent name"
          },
          "agent_definition": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Model name for this agent, or null if no structured output applies"
          }
        }
      },
      "DownloadRequest": {
        "type": "model",
        "fields": {
          "confirmation_only": {
            "type": "bool",
            "description": "If true, show confirmation UI before creating files; if false, create files immediately then show download UI. Recommended: true for user control."
          },
          "storage_backend": {
            "type": "str",
            "description": "Storage backend for uploads: 'none' (default, browser download only), 's3' (future: S3 upload), 'local' (future: server-side copy). Use 'none' unless specific storage required."
          },
          "description": {
            "type": "optional_str",
            "description": "Optional description for download (currently unused; reserve for future metadata). Use null unless specific requirement."
          }
        }
      },
      "WorkflowStrategyModule": {
        "type": "model",
        "fields": {
          "module_name": {
            "type": "str",
            "description": "Module name in format 'Module N: Strategic Purpose'"
          },
          "module_index": {
            "type": "int",
            "description": "Zero-based index of this module (0 = Module 1, 1 = Module 2, etc.)"
          },
          "module_description": {
            "type": "str",
            "description": "Strategic description of what happens in this module and why"
          },
          "pattern_id": {
            "type": "int",
            "description": "AG2 pattern ID (1-9) aligned to this module."
          },
          "pattern_name": {
            "type": "str",
            "description": "Human-readable AG2 pattern name aligned to this module."
          },
          "agents_needed": {
            "type": "list",
            "items": "str",
            "description": "Agent names this module requires (guidance list; full specs defined in ModuleAgents)."
          }
        }
      },
      "WorkflowStrategy": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Human-readable workflow name in Title Case With Spaces"
          },
          "workflow_description": {
            "type": "str",
            "description": "Description: When [TRIGGER], workflow [ACTIONS], resulting in [VALUE]"
          },
          "human_in_loop": {
            "type": "bool",
            "description": "Global flag: Does this workflow involve ANY human interaction? (True for chat, False for fully automated background tasks)"
          },
          "pattern": {
            "type": "list",
            "items": "str",
            "description": "List of AG2 orchestration patterns"
          },
          "trigger": {
            "type": "literal",
            "values": [
              "chat",
              "form_submit",
              "schedule",
              "database_condition",
              "webhook"
            ],
            "description": "Workflow trigger mechanism"
          },
          "initiated_by": {
            "type": "literal",
            "values": [
              "user",
              "system",
              "external_event"
            ],
            "description": "Who/what initiates this workflow"
          },
          "modules": {
            "type": "list",
            "items": "WorkflowStrategyModule",
            "description": "Complete multi-module roadmap. Must contain ALL modules implied by the user request (minimum 3 for complex workflows). Each module must have unique numbered prefix (Module 1:, Module 2:, etc.) in sequential order."
          }
        }
      },
      "ModuleAgents": {
        "type": "model",
        "fields": {
          "module_index": {
            "type": "int",
            "description": "Zero-based index matching the module position in WorkflowStrategy.modules (0 = Module 1, 1 = Module 2, etc.)"
          },
          "agents": {
            "type": "list",
            "items": "WorkflowAgent",
            "description": "Agent specifications for this module (at least one). Use agents_needed from strategy module to guide agent design."
          }
        }
      },
      "LifecycleOperation": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Human-readable lifecycle operation label."
          },
          "trigger": {
            "type": "literal",
            "values": [
              "before_chat",
              "after_chat",
              "before_agent",
              "after_agent"
            ],
            "description": "Lifecycle boundary where this operation executes."
          },
          "target": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Agent name for agent-scoped hooks; null for chat-level triggers.",
            "default": null
          },
          "description": {
            "type": "str",
            "description": "Purpose of the lifecycle operation."
          }
        }
      },
      "CodeFile": {
        "type": "model",
        "fields": {
          "filename": {
            "type": "str",
            "description": "Relative path (using forward slashes) where this file should be written."
          },
          "content": {
            "type": "str",
            "description": "Complete file contents with real newlines. Do not escape code fences or truncate output."
          },
          "installRequirements": {
            "type": "list",
            "items": "str",
            "description": "External packages required for this file. Use [] when none are needed."
          }
        }
      },
      "RequiredTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Tool function name (snake_case, e.g., 'analyze_request', 'submit_feedback')"
          },
          "type": {
            "type": "str",
            "allowed_values": [
              "Agent_Tool",
              "UI_Tool"
            ],
            "description": "Tool type: Agent_Tool (agent explicitly calls) or UI_Tool (runtime auto-invokes when structured output emitted)"
          },
          "scope": {
            "type": "str",
            "allowed_values": [
              "shared",
              "module_specific"
            ],
            "description": "Tool scope: shared (multiple agents across modules use this) or module_specific (single agent/module owns this)"
          },
          "purpose": {
            "type": "str",
            "description": "What this tool does and why it's needed (1-2 sentences)"
          }
        }
      },
      "ThirdPartyIntegration": {
        "type": "model",
        "fields": {
          "service": {
            "type": "str",
            "description": "Official third-party service name (PascalCase, e.g., 'Stripe', 'HubSpot', 'SalesforceServiceCloud')."
          },
          "capabilities": {
            "type": "str",
            "description": "What this integration enables for the workflow (1-2 sentences grounded in user requirements)."
          },
          "auth": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Authentication mechanism required (e.g., 'OAuth2', 'API Key'). Use null only when user explicitly states auth is handled elsewhere."
          }
        }
      },
      "RequiredContextVariable": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Variable name (snake_case, e.g., 'routing_started', 'current_iteration')"
          },
          "type": {
            "type": "str",
            "allowed_values": [
              "config",
              "data_reference",
              "data_entity",
              "computed",
              "state",
              "external"
            ],
            "description": "Variable type: config (deployment configuration from env vars), data_reference (read existing MongoDB data), data_entity (create new MongoDB data), computed (business logic outputs), state (workflow orchestration state with transitions), external (third-party API data with caching/retry)"
          },
          "trigger_hint": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Simple description of when/how this variable gets set (e.g., 'Set when DownloadAgent completes download', 'User provides city name'). Use null when no natural language description is available."
          },
          "purpose": {
            "type": "str",
            "description": "What this variable tracks and why it's needed (1-2 sentences)"
          }
        }
      },
      "RequiredLifecycleOperation": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Operation name (e.g., 'Log Domain Classification', 'Increment Iteration')"
          },
          "trigger": {
            "type": "str",
            "allowed_values": [
              "before_chat",
              "after_chat",
              "before_agent",
              "after_agent"
            ],
            "description": "When this operation executes relative to agent/chat lifecycle"
          },
          "target": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Target agent name (PascalCase) for agent-level hooks; use null for chat-level hooks. See docs/runtime/lifecycle_tools.md for trigger/target contract."
          },
          "integration": {
            "type": "str",
            "description": "Which third-party service this lifecycle operation interacts with (e.g., 'Stripe', 'MongoDB', 'none' for internal-only)"
          },
          "purpose": {
            "type": "str",
            "description": "Why this lifecycle operation exists and what business value it provides (1-2 sentences)"
          }
        }
      },
      "WorkflowLifecycleToolRef": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Lifecycle tool name (e.g., 'initialize_context', 'finalize_transcript')"
          },
          "purpose": {
            "type": "str",
            "description": "What the lifecycle tool accomplishes for the workflow (1-2 sentences)"
          },
          "trigger": {
            "type": "literal",
            "values": [
              "before_chat",
              "after_chat"
            ],
            "description": "When this lifecycle tool runs relative to the chat session"
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service engaged by this lifecycle tool (use null when none)"
          }
        }
      },
      "WorkflowUIComponent": {
        "type": "model",
        "fields": {
          "module_name": {
            "type": "str",
            "description": "Module name or label (as surfaced in the Action Plan) where this UI tool appears."
          },
          "agent": {
            "type": "str",
            "description": "PascalCase agent expected to emit the UI tool."
          },
          "tool": {
            "type": "str",
            "description": "Snake_case tool function name associated with the UI surface."
          },
          "label": {
            "type": "str",
            "description": "User-facing label or CTA text so the architect narrative can reference the UI affordance verbatim."
          },
          "component": {
            "type": "str",
            "description": "React component name (PascalCase) used by the UI tool."
          },
          "display": {
            "type": "literal",
            "values": [
              "inline",
              "artifact"
            ],
            "description": "Visual placement hint: 'inline' (conversational, in chat flow) or 'artifact' (separate tray delivery)."
          },
          "ui_pattern": {
            "type": "literal",
            "values": [
              "single_step",
              "two_step_confirmation",
              "multi_step"
            ],
            "description": "Expected interaction cadence: 'single_step' (data collection, agent continues), 'two_step_confirmation' (user reviews and approves/rejects), 'multi_step' (iterative refinement loop)."
          },
          "summary": {
            "type": "str",
            "description": "<=200 char narrative explaining what the user sees or confirms at this component."
          }
        }
      },
      "RequiredWorkflow": {
        "type": "model",
        "fields": {
          "workflow": {
            "type": "str",
            "description": "Name of the workflow that must be completed before this workflow can start (e.g., 'Generator', 'Build')"
          },
          "status": {
            "type": "str",
            "description": "Required completion status for the prerequisite workflow (typically 'completed')"
          }
        }
      },
      "RequiredArtifact": {
        "type": "model",
        "fields": {
          "artifact_type": {
            "type": "str",
            "description": "Type of artifact this workflow consumes (e.g., 'ActionPlan', 'BuildManifest', 'DeploymentConfig')"
          },
          "source_workflow": {
            "type": "str",
            "description": "Name of the workflow that produces this artifact (e.g., 'Generator' produces ActionPlan)"
          }
        }
      },
      "WorkflowDependencies": {
        "type": "model",
        "fields": {
          "required_workflows": {
            "type": "list",
            "items": "RequiredWorkflow",
            "description": "List of workflows that must complete before this workflow can start. Use [] when no workflow dependencies exist."
          }
        }
      },
      "TechnicalBlueprint": {
        "type": "model",
        "fields": {
          "global_context_variables": {
            "type": "list",
            "items": "RequiredContextVariable",
            "description": "Workflow-wide context variables that downstream agents must honor"
          },
          "ui_components": {
            "type": "list",
            "items": "WorkflowUIComponent",
            "description": "Module-aligned summary of expected UI interactions (inline vs artifact) so Action Plan narratives can highlight user components. Use [] when the workflow has no UI tools."
          },
          "before_chat_lifecycle": {
            "type": "union",
            "variants": [
              "WorkflowLifecycleToolRef",
              "null"
            ],
            "description": "Lifecycle tool executed before the chat session begins (null when not needed)"
          },
          "after_chat_lifecycle": {
            "type": "union",
            "variants": [
              "WorkflowLifecycleToolRef",
              "null"
            ],
            "description": "Lifecycle tool executed after the chat session completes (null when not needed)"
          },
          "workflow_dependencies": {
            "type": "union",
            "variants": [
              "WorkflowDependencies",
              "null"
            ],
            "description": "Dependencies on other workflows (required_workflows). Set to null for first/standalone workflows with no dependencies."
          }
        }
      },
      "PatternSelection": {
        "type": "model",
        "fields": {
          "selected_pattern": {
            "type": "int",
            "description": "Pattern ID (1-9) representing the selected AG2 orchestration pattern. Pattern Legend: 1=Context-Aware Routing, 2=Escalation, 3=Feedback Loop, 4=Hierarchical, 5=Organic, 6=Pipeline, 7=Redundant, 8=Star, 9=Triage with Tasks"
          },
          "pattern_name": {
            "type": "str",
            "description": "Human-readable pattern name (e.g., 'Context-Aware Routing', 'Pipeline', etc.)"
          }
        }
      },
      "PatternSelectionOutput": {
        "type": "model",
        "fields": {
          "PatternSelection": {
            "type": "PatternSelection",
            "description": "AG2 pattern selection with ID and name only (guidance injected via hooks)"
          }
        }
      },
      "WorkflowStrategyOutput": {
        "type": "model",
        "fields": {
          "WorkflowStrategy": {
            "type": "WorkflowStrategy",
            "description": "High-level workflow architecture"
          }
        }
      },
      "TechnicalBlueprintOutput": {
        "type": "model",
        "fields": {
          "TechnicalBlueprint": {
            "type": "TechnicalBlueprint",
            "description": "Workflow-wide context variables and lifecycle hooks authored by WorkflowArchitectAgent. Semantic wrapper key (PascalCase) for loose coupling - downstream agents reference TechnicalBlueprint, not WorkflowArchitectAgent."
          }
        }
      },
      "ModuleAgentsOutput": {
        "type": "model",
        "fields": {
          "ModuleAgents": {
            "type": "list",
            "items": "ModuleAgents",
            "description": "Ordered list of agent specifications, one entry per module from WorkflowStrategy. Array length MUST match strategy module count. Semantic wrapper key (PascalCase) for loose coupling - downstream agents reference ModuleAgents, not WorkflowImplementationAgent."
          }
        }
      },
      "MermaidSequenceDiagramOutput": {
        "type": "model",
        "fields": {
          "MermaidSequenceDiagram": {
            "type": "MermaidSequenceDiagram",
            "description": "Diagram payload rendered after the Action Plan is approved."
          },
          "agent_message": {
            "type": "str",
            "description": "Concise invitation (<=140 chars) asking the user to review the diagram."
          }
        }
      },
      "DownloadRequestOutput": {
        "type": "model",
        "fields": {
          "agent_message": {
            "type": "str",
            "description": "Concise message (\u2264140 chars) shown to user in download UI. Example: 'Ready to download your workflow bundle?' Keep action-oriented and brief."
          }
        }
      },
      "ToolsManifestOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "ToolSpec",
            "description": "List of tool entries (mirrors tools.json format)"
          },
          "lifecycle_tools": {
            "type": "list",
            "items": "ToolSpec",
            "description": "List of lifecycle tool entries (optional, can be empty array or omitted). These are workflow-level hooks that execute at orchestration boundaries (before_chat, after_chat, before_agent, after_agent)."
          }
        }
      },
      "RuntimeAgentsOutput": {
        "type": "model",
        "fields": {
          "agents": {
            "type": "list",
            "items": "AgentDefinition"
          }
        }
      },
      "UIToolsFilesOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "CodeFile",
            "description": "Ordered list of UI tool files (Python async functions + React components) to write to disk."
          }
        }
      },
      "AgentToolsFilesOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "CodeFile",
            "description": "Ordered list of backend agent tool implementation files to write to disk."
          }
        }
      },
      "ContextVariablesPlanOutput": {
        "type": "model",
        "fields": {
          "ContextVariablesPlan": {
            "type": "ContextVariablesPlan",
            "description": "Complete plan with definitions dict (all variables) and agents dict (exposure mappings)."
          }
        }
      },
      "HandoffRulesOutput": {
        "type": "model",
        "fields": {
          "handoff_rules": {
            "type": "list",
            "items": "HandoffRule"
          }
        }
      },
      "StructuredModelsOutput": {
        "type": "model",
        "fields": {
          "models": {
            "type": "list",
            "items": "StructuredModelDefinition",
            "description": "Data models to capture"
          },
          "registry": {
            "type": "list",
            "items": "AgentRegistryEntry"
          }
        }
      },
      "OrchestrationConfigOutput": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Workflow identifier"
          },
          "max_turns": {
            "type": "int",
            "description": "Maximum conversation turns"
          },
          "human_in_the_loop": {
            "type": "bool",
            "description": "Whether human interaction is required"
          },
          "startup_mode": {
            "type": "literal",
            "values": [
              "AgentDriven",
              "UserDriven",
              "BackendOnly"
            ]
          },
          "orchestration_pattern": {
            "type": "str",
            "default": "DefaultPattern"
          },
          "initial_message_to_user": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Message shown to user (UserDriven only)"
          },
          "initial_message": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Initial workflow message (AgentDriven/BackendOnly)"
          },
          "recipient": {
            "type": "str",
            "description": "First agent to receive message"
          },
          "visual_agents": {
            "type": "list",
            "items": "str",
            "description": "Agents whose messages are visible in UI"
          }
        }
      },
      "HookFilesOutput": {
        "type": "model",
        "fields": {
          "hook_files": {
            "type": "list",
            "items": "HookFile",
            "description": "Array of hook file objects (can be empty [] if no custom hooks needed)"
          }
        }
      }
    },
    "registry": {
      "InterviewAgent": null,
      "PatternAgent": "PatternSelectionOutput",
      "WorkflowStrategyAgent": "WorkflowStrategyOutput",
      "WorkflowArchitectAgent": "TechnicalBlueprintOutput",
      "WorkflowImplementationAgent": "ModuleAgentsOutput",
      "ProjectOverviewAgent": "MermaidSequenceDiagramOutput",
      "ToolsManagerAgent": "ToolsManifestOutput",
      "UIFileGenerator": "UIToolsFilesOutput",
      "AgentToolsFileGenerator": "AgentToolsFilesOutput",
      "HookAgent": "HookFilesOutput",
      "AgentsAgent": "RuntimeAgentsOutput",
      "ContextVariablesAgent": "ContextVariablesPlanOutput",
      "OrchestratorAgent": "OrchestrationConfigOutput",
      "HandoffsAgent": "HandoffRulesOutput",
      "StructuredOutputsAgent": "StructuredModelsOutput",
      "DownloadAgent": "DownloadRequestOutput"
    }
  }
}
