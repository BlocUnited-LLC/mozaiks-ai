{
  "structured_outputs": {
    "models": {
      "AgentTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Tool function name (snake_case). The actual callable that the agent invokes."
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service this tool interacts with (PascalCase). Examples: 'Stripe', 'Slack', 'OpenAI', 'GitHub'. Use null for tools that don't require external API calls."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of what this tool does and why the agent needs it (<=140 chars)."
          }
        }
      },
      "LifecycleTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Lifecycle tool function name (snake_case). The actual callable that executes the lifecycle operation."
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service this lifecycle tool interacts with (PascalCase). Use null for internal-only operations."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of what this lifecycle operation does (<=140 chars)."
          },
          "trigger": {
            "type": "str",
            "allowed_values": [
              "before_agent",
              "after_agent"
            ],
            "description": "When this lifecycle operation executes relative to the agent's main work."
          }
        }
      },
      "SystemHook": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "System hook identifier (snake_case). Examples: 'update_agent_state', 'process_message_before_send', 'process_last_received_message', 'process_all_messages_before_reply'."
          },
          "purpose": {
            "type": "str",
            "description": "Brief explanation of why this agent needs this specific system hook (<=140 chars)."
          }
        }
      },
      "WorkflowAgent": {
        "type": "model",
        "fields": {
          "agent_name": {
            "type": "str",
            "description": "Agent identifier (unique within the workflow)"
          },
          "description": {
            "type": "str",
            "description": "Short human-readable description of the agent's responsibilities (displayed in the UI)."
          },
          "agent_tools": {
            "type": "list",
            "items": "AgentTool",
            "description": "Agent-specific tools this agent can call. Each tool specifies name, integration, and purpose. Use [] when no agent tools are required."
          },
          "lifecycle_tools": {
            "type": "list",
            "items": "LifecycleTool",
            "description": "Lifecycle operation tools this agent executes. Each tool specifies name, integration, purpose, and trigger timing. Use [] when no lifecycle tools are required."
          },
          "system_hooks": {
            "type": "list",
            "items": "SystemHook",
            "description": "System hooks this agent uses for runtime behavior modification. Each hook specifies name and purpose. Use [] when no system hooks are required."
          },
          "human_interaction": {
            "type": "str",
            "allowed_values": [
              "none",
              "context",
              "approval"
            ],
            "description": "Human involvement mode for THIS SPECIFIC AGENT. none = fully automated execution; context = pauses to collect user information/clarification; approval = pauses for human decision/sign-off. Choose based on phase approval requirements and collaboration notes: approval phases require 'approval'; collaborative intake phases may use 'context'; otherwise use 'none'."
          }
        }
      },
      "WorkflowPhase": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Phase title (e.g., Intake, Execution, QA)"
          },
          "description": {
            "type": "str",
            "description": "Description of the phase goals and outputs. Should include Phase prefix (e.g., 'Phase 1:') and handoff clause when applicable."
          },
          "agents": {
            "type": "list",
            "items": "WorkflowAgent",
            "description": "Agents participating in this phase (at least one)."
          }
        }
      },
      "WorkflowSpec": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Human-readable workflow name"
          },
          "description": {
            "type": "str",
            "description": "Paragraph-length summary (400-600 chars) explaining when the workflow triggers, what it does, and what business value it delivers. MUST follow trigger-specific patterns defined in ActionPlanArchitect instructions."
          },
          "initiated_by": {
            "type": "literal",
            "values": [
              "user",
              "system",
              "external_event"
            ],
            "description": "Who or what starts this workflow. user = human explicitly starts (form submit, button click, chat); system = platform automatically starts (cron schedule, database condition); external_event = external service triggers (webhook from third-party)."
          },
          "trigger_type": {
            "type": "literal",
            "values": [
              "form_submit",
              "chat_start",
              "cron_schedule",
              "webhook",
              "database_condition"
            ],
            "description": "Specific mechanism that initiates workflow execution. form_submit = user submits web form; chat_start = user initiates conversational session; cron_schedule = time-based trigger; webhook = external service sends HTTP POST; database_condition = internal database state meets trigger criteria."
          },
          "pattern": {
            "type": "literal",
            "values": [
              "ContextAwareRouting",
              "Escalation",
              "FeedbackLoop",
              "Hierarchical",
              "Organic",
              "Pipeline",
              "Redundant",
              "Star",
              "TriageWithTasks"
            ],
            "description": "AG2 orchestration pattern applied to the workflow."
          },
          "lifecycle_operations": {
            "type": "list",
            "items": "LifecycleOperation",
            "description": "Lifecycle hooks executed between phases or agents (may be empty)."
          },
          "phases": {
            "type": "list",
            "items": "WorkflowPhase",
            "description": "Ordered list of phases that make up the workflow. MUST mirror the phases list from WorkflowStrategyCall exactly (same count, same phase names including 'Phase N:' prefix, same order, same approval flags). Multi-phase workflows are expected; do not collapse phases."
          }
        }
      },
      "ActionPlan": {
        "type": "model",
        "fields": {
          "workflow": {
            "type": "WorkflowSpec",
            "description": "Workflow definition produced by the ActionPlanArchitect"
          }
        }
      },
      "ActionPlanCall": {
        "type": "model",
        "fields": {
          "ActionPlan": {
            "type": "ActionPlan",
            "description": "Workflow container passed to the Action Plan UI tool (PascalCase to match tool arg)."
          }
        }
      },
      "MermaidSequenceDiagram": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Workflow name this diagram represents"
          },
          "mermaid_diagram": {
            "type": "str",
            "description": "Complete Mermaid sequence diagram text, beginning with 'sequenceDiagram'. Must include required blank line after participant declarations."
          },
          "legend": {
            "type": "list",
            "items": "str",
            "description": "Optional phase legend entries (P1: Phase Name). Provide [] when no legend is required."
          }
        }
      },
      "DatabaseRef": {
        "type": "model",
        "NOTE": "DEPRECATED - Kept for backwards compatibility. New context variables use definitions+agents structure with source.type discrimination.",
        "fields": {
          "database_name": {
            "type": "str",
            "description": "Name of the target database"
          },
          "collection": {
            "type": "str",
            "description": "Collection name where the variable resides"
          },
          "search_by": {
            "type": "str",
            "description": "Field used as the query key when accessing this variable"
          },
          "field": {
            "type": "str",
            "description": "Specific field in the collection that stores the variable"
          }
        }
      },
      "DatabaseVariable": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Database variable name"
          },
          "description": {
            "type": "str",
            "description": "Purpose / usage in workflow"
          },
          "type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Optional type hint for downstream consumers (e.g., string|boolean)"
          },
          "database": {
            "type": "DatabaseRef",
            "description": "Database reference information"
          }
        }
      },
      "EnvironmentVariable": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Environment variable name"
          },
          "description": {
            "type": "str",
            "description": "Purpose / usage in workflow"
          },
          "type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Optional type hint (boolean|integer|string)"
          },
          "env_var": {
            "type": "str",
            "description": "Underlying environment variable key"
          },
          "default": {
            "type": "union",
            "variants": [
              "null",
              "str",
              "bool",
              "int"
            ],
            "description": "Fallback value when the environment variable is not set"
          }
        }
      },
      "DeclarativeVariable": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Declarative variable name"
          },
          "description": {
            "type": "str",
            "description": "Purpose / usage in workflow"
          },
          "type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Optional type hint (string|boolean|integer|dict)"
          },
          "value": {
            "type": "union",
            "variants": [
              "str",
              "bool",
              "int",
              "float",
              "dict"
            ],
            "description": "Literal value injected into context"
          }
        }
      },
      "DerivedTriggerMatch": {
        "type": "model",
        "fields": {
          "equals": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Exact string match required for the trigger (agent_text only)."
          },
          "contains": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Substring match evaluated against emitted agent text (agent_text only)."
          },
          "regex": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Regular expression applied to emitted agent text (agent_text only)."
          }
        }
      },
      "DerivedTrigger": {
        "type": "model",
        "fields": {
          "type": {
            "type": "literal",
            "values": [
              "agent_text",
              "ui_response"
            ],
            "description": "Trigger mode: agent_text (passive detection) or ui_response (active UI tool response)."
          },
          "agent": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Agent whose output is monitored (required when type=agent_text)."
          },
          "match": {
            "type": "union",
            "variants": [
              "DerivedTriggerMatch",
              "null"
            ],
            "description": "Match conditions for agent_text triggers. Must be omitted for ui_response triggers."
          },
          "tool": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Snake_case tool name responsible for updating the variable (required when type=ui_response)."
          },
          "response_key": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Key in the UI tool response payload whose value seeds the derived variable (required when type=ui_response)."
          }
        }
      },
      "DerivedVariable": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Derived variable name (computed, not persisted)."
          },
          "description": {
            "type": "str",
            "description": "Purpose / effect of the derived variable. Context variables remain hidden from the frontend unless surfaced explicitly via UI tooling."
          },
          "type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Optional type hint for downstream consumers (e.g., string|boolean|json)."
          },
          "default": {
            "type": "union",
            "variants": [
              "null",
              "str",
              "bool",
              "int",
              "float",
              "dict",
              "list"
            ],
            "description": "Initial value prior to any triggers firing."
          },
          "triggers": {
            "type": "list",
            "items": "DerivedTrigger",
            "description": "Ordered trigger definitions supporting both agent_text and ui_response contracts."
          }
        }
      },
      "ContextVariableSource": {
        "type": "model",
        "fields": {
          "type": {
            "type": "literal",
            "values": [
              "database",
              "environment",
              "static",
              "derived"
            ],
            "description": "Source classification for the context variable."
          },
          "database_name": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Mongo database name (database sources only)."
          },
          "collection": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Mongo collection name (database sources only)."
          },
          "search_by": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Field used to locate the document (database sources)."
          },
          "field": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Field extracted from the database document."
          },
          "env_var": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Environment variable name (environment sources)."
          },
          "default": {
            "type": "union",
            "variants": [
              "str",
              "int",
              "bool",
              "null"
            ],
            "description": "Fallback value when the source is unavailable."
          },
          "value": {
            "type": "union",
            "variants": [
              "str",
              "int",
              "bool",
              "null"
            ],
            "description": "Literal value for static sources."
          },
          "triggers": {
            "type": "list",
            "items": "DerivedTrigger",
            "description": "Trigger definitions for derived sources. Use [] for non-derived types.",
            "default": []
          }
        }
      },
      "ContextVariableDefinitionEntry": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Unique snake_case variable name."
          },
          "type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Canonical data type for downstream casting (string|integer|boolean etc.)."
          },
          "description": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Human readable description explaining the variable purpose."
          },
          "source": {
            "type": "ContextVariableSource",
            "description": "Source metadata describing where the value originates."
          }
        }
      },
      "ContextVariableAgentExposure": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Agent name receiving these variables."
          },
          "variables": {
            "type": "list",
            "items": "str",
            "description": "Variables exposed to the agent (empty list permitted).",
            "default": []
          }
        }
      },
      "ContextVariablesPlan": {
        "type": "model",
        "fields": {
          "definitions": {
            "type": "list",
            "items": "ContextVariableDefinitionEntry",
            "description": "Ordered list of context variable definitions (each entry includes name, type, description, and source metadata)."
          },
          "agents": {
            "type": "list",
            "items": "ContextVariableAgentExposure",
            "description": "Agent exposure entries describing which variables are visible to each agent."
          }
        }
      },
      "UIConfig": {
        "type": "model",
        "fields": {
          "component": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "React component name (UI_Tool only)"
          },
          "mode": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Legacy display metadata (inline or artifact). Should mirror display for backward compatibility."
          },
          "display": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Primary rendering hint for runtime events: inline or artifact."
          },
          "label": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Primary call-to-action or heading copy surfaced by the UI component."
          },
          "description": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Helper copy that must be rendered verbatim in the UI tool."
          },
          "interaction_pattern": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Indicates expected user flow (single_step, two_step_confirmation, multi_step)."
          }
        }
      },
      "ToolSpec": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Owning agent (or primary agent)"
          },
          "file": {
            "type": "str",
            "description": "Python module file name"
          },
          "function": {
            "type": "str",
            "description": "Async function inside the file"
          },
          "description": {
            "type": "str",
            "description": "Tool purpose (<=140 chars, no secrets)"
          },
          "tool_type": {
            "type": "literal",
            "values": [
              "UI_Tool",
              "Agent_Tool"
            ],
            "description": "Tool type"
          },
          "auto_invoke": {
            "type": "union",
            "variants": [
              "bool",
              "null"
            ],
            "description": "Controls whether tool is automatically invoked when agent produces structured output. Default: true for UI_Tool, false for Agent_Tool. Set true for Agent_Tools whose structured output must be stored in context for downstream agents to access. Omit (null) to use defaults."
          },
          "ui": {
            "type": "UIConfig",
            "description": "UI metadata (nulls for Agent_Tool)"
          }
        }
      },
      "UIToolFile": {
        "type": "model",
        "fields": {
          "tool_name": {
            "type": "str",
            "description": "Tool function name (snake_case, basename only, no path prefix)"
          },
          "py_content": {
            "type": "str",
            "description": "Complete Python async function source code as string (no placeholders)"
          },
          "js_content": {
            "type": "str",
            "description": "Complete React component source code as string (no placeholders)"
          }
        }
      },
      "AgentToolFile": {
        "type": "model",
        "fields": {
          "tool_name": {
            "type": "str",
            "description": "Tool function name (snake_case, basename only, no path prefix)"
          },
          "py_content": {
            "type": "str",
            "description": "Complete Python function source code as string (no placeholders, can be sync or async)"
          }
        }
      },
      "HookFile": {
        "type": "model",
        "fields": {
          "filename": {
            "type": "str",
            "description": "Hook file name (e.g., 'validate_budget.py', 'audit_decisions.py')"
          },
          "hook_type": {
            "type": "literal",
            "values": [
              "before_chat",
              "after_chat",
              "update_agent_state"
            ],
            "description": "Lifecycle hook type"
          },
          "py_content": {
            "type": "str",
            "description": "Complete Python code for hook function"
          }
        }
      },
      "PromptSectionContent": {
        "type": "model",
        "description": "Content container for a single prompt section (heading + text)",
        "fields": {
          "heading": {
            "type": "str",
            "description": "Section heading as displayed in system message (UPPERCASE with [BRACKETS])"
          },
          "content": {
            "type": "str",
            "description": "Section text content"
          }
        }
      },
      "PromptSections": {
        "type": "model",
        "description": "Standardized 9-section prompt structure for NEW agents. Enforces consistency and completeness via schema validation. Runtime is adaptable and can compose ANY section structure (use prompt_sections_custom for non-standard needs), but this fixed schema ensures future agents follow consistent patterns.",
        "fields": {
          "role": {
            "type": "PromptSectionContent",
            "description": "Agent identity (single sentence). Heading: [ROLE]"
          },
          "objective": {
            "type": "PromptSectionContent",
            "description": "Key deliverables (2-4 bullets). Heading: [OBJECTIVE]"
          },
          "context": {
            "type": "PromptSectionContent",
            "description": "Inputs, outputs, workflow position, exposed context variables. Heading: [CONTEXT]"
          },
          "runtime_integrations": {
            "type": "PromptSectionContent",
            "description": "What runtime handles automatically. Heading: [RUNTIME INTEGRATION]"
          },
          "guidelines": {
            "type": "PromptSectionContent",
            "description": "Legal compliance, output rules (MUST start with legal statement). Heading: [GUIDELINES]"
          },
          "instructions": {
            "type": "PromptSectionContent",
            "description": "Step-by-step algorithm with embedded subsections (context variables, coordination tokens, tools). Heading: [INSTRUCTIONS]"
          },
          "examples": {
            "type": "PromptSectionContent",
            "description": "Concrete usage examples. Heading: [EXAMPLES]"
          },
          "json_output_compliance": {
            "type": "PromptSectionContent",
            "description": "JSON escaping rules (ONLY if structured_outputs_required=true). Heading: [JSON OUTPUT COMPLIANCE]",
            "required": false
          },
          "output_format": {
            "type": "PromptSectionContent",
            "description": "Expected schema. Heading: [OUTPUT FORMAT]"
          }
        },
        "required": [
          "role",
          "objective",
          "context",
          "runtime_integrations",
          "guidelines",
          "instructions",
          "examples",
          "output_format"
        ]
      },
      "AgentDefinition": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Agent variable name"
          },
          "display_name": {
            "type": "str",
            "description": "Agent display name"
          },
          "prompt_sections": {
            "type": "PromptSections",
            "description": "Standardized prompt sections (fixed 9-field structure). Factory._compose_prompt_sections() converts this to system_message string for ConversableAgent. ALL new agents MUST use this field with exactly 9 required sections (or 8 if json_output_compliance omitted). Enforces schema compliance and prevents section omission.",
            "required": false
          },
          "max_consecutive_auto_reply": {
            "type": "int",
            "default": 10
          },
          "auto_tool_mode": {
            "type": "bool",
            "description": "True when the runtime should auto-invoke UI tools for this agent (agent has at least one UI tool entry)."
          },
          "structured_outputs_required": {
            "type": "bool",
            "description": "True when the agent must produce structured outputs (Pydantic model enforced); false otherwise."
          }
        }
      },
      "HandoffRule": {
        "type": "model",
        "fields": {
          "source_agent": {
            "type": "str",
            "description": "Source agent name"
          },
          "target_agent": {
            "type": "str",
            "description": "Target agent name or 'user' or 'terminate'"
          },
          "handoff_type": {
            "type": "literal",
            "values": [
              "condition",
              "after_work"
            ],
            "description": "Type of handoff: 'condition' for immediate evaluation (context or LLM-based), 'after_work' for post-agent-completion evaluation"
          },
          "condition": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Condition text: null for unconditional after_work, expression string with ${var} for context conditions, natural language for LLM conditions"
          },
          "condition_type": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Condition evaluation method: 'expression' for context variable expressions (${...}), 'string_llm' for LLM natural language evaluation, null to auto-detect (${} triggers expression, else LLM)"
          },
          "condition_scope": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Evaluation timing for context conditions: 'pre' for pre-reply evaluation (re-checks every turn, ideal for UI interactions), 'post' for post-reply evaluation, null for default (LLM conditions ignore this field)"
          },
          "transition_target": {
            "type": "literal",
            "values": [
              "AgentTarget",
              "RevertToUserTarget",
              "TerminateTarget"
            ],
            "description": "Type of transition target"
          }
        },
        "required": [
          "source_agent",
          "target_agent",
          "handoff_type",
          "transition_target"
        ]
      },
      "StructuredModelField": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Field name"
          },
          "type": {
            "type": "str",
            "description": "Field type (str|int|bool|list|union with variants)"
          },
          "description": {
            "type": "str",
            "description": "What this field represents"
          }
        }
      },
      "StructuredModelDefinition": {
        "type": "model",
        "fields": {
          "model_name": {
            "type": "str",
            "description": "Name of the model"
          },
          "fields": {
            "type": "list",
            "items": "StructuredModelField"
          }
        }
      },
      "AgentRegistryEntry": {
        "type": "model",
        "fields": {
          "agent": {
            "type": "str",
            "description": "Agent name"
          },
          "agent_definition": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Model name for this agent, or null if no structured output applies"
          }
        }
      },
      "DownloadRequest": {
        "type": "model",
        "fields": {
          "confirmation_only": {
            "type": "bool",
            "description": "If true, show confirmation UI before creating files; if false, create files immediately then show download UI. Recommended: true for user control."
          },
          "storage_backend": {
            "type": "str",
            "description": "Storage backend for uploads: 'none' (default, browser download only), 's3' (future: S3 upload), 'local' (future: server-side copy). Use 'none' unless specific storage required."
          },
          "description": {
            "type": "optional_str",
            "description": "Optional description for download (currently unused; reserve for future metadata). Use null unless specific requirement."
          }
        }
      },
      "WorkflowStrategyPhase": {
        "type": "model",
        "fields": {
          "phase_name": {
            "type": "str",
            "description": "Phase name in format 'Phase N: Strategic Purpose'"
          },
          "phase_index": {
            "type": "int",
            "description": "Zero-based index of this phase (0 = Phase 1, 1 = Phase 2, etc.)"
          },
          "phase_description": {
            "type": "str",
            "description": "Strategic description of what happens in this phase and why"
          },
          "human_in_loop": {
            "type": "bool",
            "description": "Whether this phase requires human approval"
          },
          "agents_needed": {
            "type": "str",
            "description": "Agent coordination pattern: 'single', 'parallel', or 'sequential'"
          }
        }
      },
      "WorkflowStrategy": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Human-readable workflow name in Title Case With Spaces"
          },
          "workflow_description": {
            "type": "str",
            "description": "Description: When [TRIGGER], workflow [ACTIONS], resulting in [VALUE]"
          },
          "pattern": {
            "type": "list",
            "items": "str",
            "description": "List of AG2 orchestration patterns (e.g., ['sequential', 'nested_chats'])"
          },
          "trigger": {
            "type": "literal",
            "values": [
              "chat",
              "form_submit",
              "schedule",
              "database_condition",
              "webhook"
            ],
            "description": "Workflow trigger mechanism"
          },
          "initiated_by": {
            "type": "literal",
            "values": [
              "user",
              "system",
              "external_event"
            ],
            "description": "Who/what initiates this workflow"
          },
          "phases": {
            "type": "list",
            "items": "WorkflowStrategyPhase",
            "description": "Complete multi-phase roadmap. Must contain ALL phases implied by the user request (minimum 3 for complex workflows). Each phase must have unique numbered prefix (Phase 1:, Phase 2:, etc.) in sequential order."
          }
        }
      },
      "PhaseAgents": {
        "type": "model",
        "fields": {
          "phase_index": {
            "type": "int",
            "description": "Zero-based index matching the phase position in WorkflowStrategy.phases (0 = Phase 1, 1 = Phase 2, etc.)"
          },
          "agents": {
            "type": "list",
            "items": "WorkflowAgent",
            "description": "Agent specifications for this phase (at least one). Use specialist_domains from strategy phase to guide agent design."
          }
        }
      },
      "LifecycleOperation": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Human-readable lifecycle operation label."
          },
          "trigger": {
            "type": "literal",
            "values": [
              "before_chat",
              "after_chat",
              "before_agent",
              "after_agent"
            ],
            "description": "Lifecycle boundary where this operation executes."
          },
          "target": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Agent name for agent-scoped hooks; null for chat-level triggers.",
            "default": null
          },
          "description": {
            "type": "str",
            "description": "Purpose of the lifecycle operation."
          }
        }
      },
      "CodeFile": {
        "type": "model",
        "fields": {
          "filename": {
            "type": "str",
            "description": "Relative path (using forward slashes) where this file should be written."
          },
          "content": {
            "type": "str",
            "description": "Complete file contents with real newlines. Do not escape code fences or truncate output."
          },
          "installRequirements": {
            "type": "list",
            "items": "str",
            "description": "External packages required for this file. Use [] when none are needed."
          }
        }
      },
      "RequiredTool": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Tool function name (snake_case, e.g., 'analyze_request', 'submit_feedback')"
          },
          "type": {
            "type": "str",
            "allowed_values": [
              "Agent_Tool",
              "UI_Tool"
            ],
            "description": "Tool type: Agent_Tool (agent explicitly calls) or UI_Tool (runtime auto-invokes when structured output emitted)"
          },
          "scope": {
            "type": "str",
            "allowed_values": [
              "shared",
              "phase_specific"
            ],
            "description": "Tool scope: shared (multiple agents across phases use this) or phase_specific (single agent/phase owns this)"
          },
          "purpose": {
            "type": "str",
            "description": "What this tool does and why it's needed (1-2 sentences)"
          }
        }
      },
      "ThirdPartyIntegration": {
        "type": "model",
        "fields": {
          "service": {
            "type": "str",
            "description": "Official third-party service name (PascalCase, e.g., 'Stripe', 'HubSpot', 'SalesforceServiceCloud')."
          },
          "capabilities": {
            "type": "str",
            "description": "What this integration enables for the workflow (1-2 sentences grounded in user requirements)."
          },
          "auth": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Authentication mechanism required (e.g., 'OAuth2', 'API Key'). Use null only when user explicitly states auth is handled elsewhere."
          }
        }
      },
      "RequiredContextVariable": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Variable name (snake_case, e.g., 'routing_started', 'current_iteration')"
          },
          "type": {
            "type": "str",
            "allowed_values": [
              "static",
              "derived",
              "environment",
              "database"
            ],
            "description": "Variable type: static (hard-coded value), derived (set by agent_text or ui_response triggers), environment (from env vars), database (from MongoDB)"
          },
          "trigger_hint": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Simple description of when/how this variable gets set (e.g., 'Set when DownloadAgent completes download', 'User provides city name'). Use null when no natural language description is available."
          },
          "purpose": {
            "type": "str",
            "description": "What this variable tracks and why it's needed (1-2 sentences)"
          }
        }
      },
      "RequiredLifecycleOperation": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Operation name (e.g., 'Log Domain Classification', 'Increment Iteration')"
          },
          "trigger": {
            "type": "str",
            "allowed_values": [
              "before_chat",
              "after_chat",
              "before_agent",
              "after_agent"
            ],
            "description": "When this operation executes relative to agent/chat lifecycle"
          },
          "target": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Target agent name (PascalCase) for agent-level hooks; use null for chat-level hooks. See docs/runtime/lifecycle_tools.md for trigger/target contract."
          },
          "integration": {
            "type": "str",
            "description": "Which third-party service this lifecycle operation interacts with (e.g., 'Stripe', 'MongoDB', 'none' for internal-only)"
          },
          "purpose": {
            "type": "str",
            "description": "Why this lifecycle operation exists and what business value it provides (1-2 sentences)"
          }
        }
      },
      "WorkflowLifecycleToolRef": {
        "type": "model",
        "fields": {
          "name": {
            "type": "str",
            "description": "Lifecycle tool name (e.g., 'initialize_context', 'finalize_transcript')"
          },
          "purpose": {
            "type": "str",
            "description": "What the lifecycle tool accomplishes for the workflow (1-2 sentences)"
          },
          "trigger": {
            "type": "literal",
            "values": [
              "before_chat",
              "after_chat"
            ],
            "description": "When this lifecycle tool runs relative to the chat session"
          },
          "integration": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Third-party service engaged by this lifecycle tool (use null when none)"
          }
        }
      },
      "PhaseTechnicalRequirements": {
        "type": "model",
        "fields": {
          "phase_index": {
            "type": "int",
            "description": "Zero-based index matching workflow_strategy phases array (0 = Phase 1)"
          },
          "phase_name": {
            "type": "str",
            "description": "Phase name from workflow_strategy for reference (e.g., 'Phase 1: Planning')"
          },
          "required_tools": {
            "type": "list",
            "items": "RequiredTool",
            "description": "Tools needed for this specific phase"
          },
          "required_context_variables": {
            "type": "list",
            "items": "RequiredContextVariable",
            "description": "Context variables needed for this specific phase"
          },
          "required_lifecycle_operations": {
            "type": "list",
            "items": "RequiredLifecycleOperation",
            "description": "Lifecycle operations needed for this specific phase"
          }
        }
      },
      "SharedRequirements": {
        "type": "model",
        "fields": {
          "integrations": {
            "type": "list",
            "items": "str",
            "description": "List of third-party integration names shared across workflow (e.g., ['Stripe', 'Slack', 'GoogleAnalytics'])"
          },
          "tools": {
            "type": "list",
            "items": "str",
            "description": "List of shared tool names (snake_case) used across multiple phases (e.g., ['send_notification', 'validate_email'])"
          },
          "context_variables": {
            "type": "list",
            "items": "str",
            "description": "List of shared context variable names (snake_case) accessible across all phases (e.g., ['workflow_started', 'current_iteration'])"
          },
          "lifecycle_operations": {
            "type": "list",
            "items": "str",
            "description": "List of shared lifecycle operation names used across workflow (e.g., ['log_workflow_start', 'save_final_state'])"
          }
        }
      },
      "WorkflowUIComponent": {
        "type": "model",
        "fields": {
          "phase_name": {
            "type": "str",
            "description": "Phase name or label (as surfaced in the Action Plan) where this UI tool appears."
          },
          "agent": {
            "type": "str",
            "description": "PascalCase agent expected to emit the UI tool."
          },
          "tool": {
            "type": "str",
            "description": "Snake_case tool function name associated with the UI surface."
          },
          "label": {
            "type": "str",
            "description": "User-facing label or CTA text so the architect narrative can reference the UI affordance verbatim."
          },
          "component": {
            "type": "str",
            "description": "React component name (PascalCase) used by the UI tool."
          },
          "display": {
            "type": "str",
            "description": "Visual placement hint (inline | artifact) that mirrors tools manifest metadata."
          },
          "interaction_pattern": {
            "type": "str",
            "description": "Expected interaction cadence (single_step | two_step_confirmation | multi_step)."
          },
          "summary": {
            "type": "str",
            "description": "<=200 char narrative explaining what the user sees or confirms at this component."
          }
        }
      },
      "RequiredWorkflow": {
        "type": "model",
        "fields": {
          "workflow": {
            "type": "str",
            "description": "Name of the workflow that must be completed before this workflow can start (e.g., 'Generator', 'Build')"
          },
          "status": {
            "type": "str",
            "description": "Required completion status for the prerequisite workflow (typically 'completed')"
          }
        }
      },
      "RequiredArtifact": {
        "type": "model",
        "fields": {
          "artifact_type": {
            "type": "str",
            "description": "Type of artifact this workflow consumes (e.g., 'ActionPlan', 'BuildManifest', 'DeploymentConfig')"
          },
          "source_workflow": {
            "type": "str",
            "description": "Name of the workflow that produces this artifact (e.g., 'Generator' produces ActionPlan)"
          }
        }
      },
      "WorkflowDependencies": {
        "type": "model",
        "fields": {
          "required_workflows": {
            "type": "list",
            "items": "RequiredWorkflow",
            "description": "List of workflows that must complete before this workflow can start. Use [] when no workflow dependencies exist."
          },
          "required_context_vars": {
            "type": "list",
            "items": "str",
            "description": "List of context variable names this workflow needs from other workflows. Use [] when no context variable dependencies exist."
          },
          "required_artifacts": {
            "type": "list",
            "items": "RequiredArtifact",
            "description": "List of artifacts this workflow consumes from other workflows. Use [] when no artifact dependencies exist."
          }
        }
      },
      "WorkflowProvides": {
        "type": "model",
        "fields": {
          "context_vars": {
            "type": "list",
            "items": "str",
            "description": "List of context variable names this workflow sets for downstream workflows to consume. Use [] when workflow doesn't provide context variables."
          },
          "artifacts": {
            "type": "list",
            "items": "str",
            "description": "List of artifact types this workflow generates for downstream workflows (e.g., 'ActionPlan', 'BuildManifest'). Use [] when workflow doesn't generate artifacts."
          }
        }
      },
      "TechnicalBlueprint": {
        "type": "model",
        "fields": {
          "global_context_variables": {
            "type": "list",
            "items": "RequiredContextVariable",
            "description": "Workflow-wide context variables that downstream agents must honor"
          },
          "ui_components": {
            "type": "list",
            "items": "WorkflowUIComponent",
            "description": "Phase-aligned summary of expected UI interactions (inline vs artifact) so Action Plan narratives can highlight user components. Use [] when the workflow has no UI tools."
          },
          "before_chat_lifecycle": {
            "type": "union",
            "variants": [
              "WorkflowLifecycleToolRef",
              "null"
            ],
            "description": "Lifecycle tool executed before the chat session begins (null when not needed)"
          },
          "after_chat_lifecycle": {
            "type": "union",
            "variants": [
              "WorkflowLifecycleToolRef",
              "null"
            ],
            "description": "Lifecycle tool executed after the chat session completes (null when not needed)"
          },
          "workflow_dependencies": {
            "type": "union",
            "variants": [
              "WorkflowDependencies",
              "null"
            ],
            "description": "Dependencies on other workflows (required_workflows, required_context_vars, required_artifacts). Set to null for first/standalone workflows with no dependencies."
          },
          "workflow_provides": {
            "type": "union",
            "variants": [
              "WorkflowProvides",
              "null"
            ],
            "description": "Outputs this workflow provides for downstream workflows (context_vars, artifacts). Set to null when workflow doesn't produce outputs for other workflows."
          }
        }
      },
      "PatternSelection": {
        "type": "model",
        "fields": {
          "selected_pattern": {
            "type": "int",
            "description": "Pattern ID (1-9) representing the selected AG2 orchestration pattern. Pattern Legend: 1=Context-Aware Routing, 2=Escalation, 3=Feedback Loop, 4=Hierarchical, 5=Organic, 6=Pipeline, 7=Redundant, 8=Star, 9=Triage with Tasks"
          },
          "pattern_name": {
            "type": "str",
            "description": "Human-readable pattern name (e.g., 'Context-Aware Routing', 'Pipeline', etc.)"
          }
        }
      },
      "PatternSelectionOutput": {
        "type": "model",
        "fields": {
          "PatternSelection": {
            "type": "PatternSelection",
            "description": "AG2 pattern selection with ID and name only (guidance injected via hooks)"
          }
        }
      },
      "WorkflowStrategyOutput": {
        "type": "model",
        "fields": {
          "WorkflowStrategy": {
            "type": "WorkflowStrategy",
            "description": "High-level workflow architecture"
          }
        }
      },
      "TechnicalBlueprintOutput": {
        "type": "model",
        "fields": {
          "TechnicalBlueprint": {
            "type": "TechnicalBlueprint",
            "description": "Workflow-wide context variables and lifecycle hooks authored by WorkflowArchitectAgent. Semantic wrapper key (PascalCase) for loose coupling - downstream agents reference TechnicalBlueprint, not WorkflowArchitectAgent."
          }
        }
      },
      "PhaseAgentsOutput": {
        "type": "model",
        "fields": {
          "PhaseAgents": {
            "type": "list",
            "items": "PhaseAgents",
            "description": "Ordered list of agent specifications, one entry per phase from WorkflowStrategy. Array length MUST match strategy phase count. Semantic wrapper key (PascalCase) for loose coupling - downstream agents reference PhaseAgents, not WorkflowImplementationAgent."
          }
        }
      },
      "MermaidSequenceDiagramOutput": {
        "type": "model",
        "fields": {
          "MermaidSequenceDiagram": {
            "type": "MermaidSequenceDiagram",
            "description": "Diagram payload rendered after the Action Plan is approved."
          },
          "agent_message": {
            "type": "str",
            "description": "Concise invitation (<=140 chars) asking the user to review the diagram."
          }
        }
      },
      "DownloadRequestOutput": {
        "type": "model",
        "fields": {
          "agent_message": {
            "type": "str",
            "description": "Concise message (140 chars) shown to user in download UI. Example: 'Ready to download your workflow bundle?' Keep action-oriented and brief."
          }
        }
      },
      "ToolsManifestOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "ToolSpec",
            "description": "List of tool entries (mirrors tools.json format)"
          },
          "lifecycle_tools": {
            "type": "list",
            "items": "ToolSpec",
            "description": "List of lifecycle tool entries (optional, can be empty array or omitted). These are workflow-level hooks that execute at orchestration boundaries (before_chat, after_chat, before_agent, after_agent)."
          }
        }
      },
      "RuntimeAgentsOutput": {
        "type": "model",
        "fields": {
          "agents": {
            "type": "list",
            "items": "AgentDefinition"
          }
        }
      },
      "UIToolsFilesOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "UIToolFile",
            "description": "Ordered list of UI tool files (Python async functions + React components) to write to disk."
          }
        }
      },
      "AgentToolsFilesOutput": {
        "type": "model",
        "fields": {
          "tools": {
            "type": "list",
            "items": "AgentToolFile",
            "description": "Ordered list of backend agent tool implementation files to write to disk."
          }
        }
      },
      "ContextVariablesPlanOutput": {
        "type": "model",
        "fields": {
          "ContextVariablesPlan": {
            "type": "ContextVariablesPlan",
            "description": "Complete plan with definitions dict (all variables) and agents dict (exposure mappings)."
          }
        }
      },
      "HandoffRulesOutput": {
        "type": "model",
        "fields": {
          "handoff_rules": {
            "type": "list",
            "items": "HandoffRule"
          }
        }
      },
      "StructuredModelsOutput": {
        "type": "model",
        "fields": {
          "models": {
            "type": "list",
            "items": "StructuredModelDefinition",
            "description": "Data models to capture"
          },
          "registry": {
            "type": "list",
            "items": "AgentRegistryEntry"
          }
        }
      },
      "OrchestrationConfigOutput": {
        "type": "model",
        "fields": {
          "workflow_name": {
            "type": "str",
            "description": "Workflow identifier"
          },
          "max_turns": {
            "type": "int",
            "description": "Maximum conversation turns"
          },
          "human_in_the_loop": {
            "type": "bool",
            "description": "Whether human interaction is required"
          },
          "startup_mode": {
            "type": "literal",
            "values": [
              "AgentDriven",
              "UserDriven",
              "BackendOnly"
            ]
          },
          "orchestration_pattern": {
            "type": "str",
            "default": "DefaultPattern"
          },
          "initial_message_to_user": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Message shown to user (UserDriven only)"
          },
          "initial_message": {
            "type": "union",
            "variants": [
              "str",
              "null"
            ],
            "description": "Initial workflow message (AgentDriven/BackendOnly)"
          },
          "recipient": {
            "type": "str",
            "description": "First agent to receive message"
          },
          "visual_agents": {
            "type": "list",
            "items": "str",
            "description": "Agents whose messages are visible in UI"
          }
        }
      },
      "HookFilesOutput": {
        "type": "model",
        "fields": {
          "hook_files": {
            "type": "list",
            "items": "HookFile",
            "description": "Array of hook file objects (can be empty [] if no custom hooks needed)"
          }
        }
      }
    },
    "registry": {
      "InterviewAgent": null,
      "PatternAgent": "PatternSelectionOutput",
      "WorkflowStrategyAgent": "WorkflowStrategyOutput",
      "WorkflowArchitectAgent": "TechnicalBlueprintOutput",
      "WorkflowImplementationAgent": "PhaseAgentsOutput",
      "ProjectOverviewAgent": "MermaidSequenceDiagramOutput",
      "ToolsManagerAgent": "ToolsManifestOutput",
      "UIFileGenerator": "UIToolsFilesOutput",
      "AgentToolsFileGenerator": "AgentToolsFilesOutput",
      "HookAgent": "HookFilesOutput",
      "AgentsAgent": "RuntimeAgentsOutput",
      "ContextVariablesAgent": "ContextVariablesPlanOutput",
      "OrchestratorAgent": "OrchestrationConfigOutput",
      "HandoffsAgent": "HandoffRulesOutput",
      "StructuredOutputsAgent": "StructuredModelsOutput",
      "DownloadAgent": "DownloadRequestOutput"
    }
  }
}