# ==============================================================================
# FILE: core/workflow/agents.py  
# DESCRIPTION: Workflow-agnostic agent factory - loads from modular YAML configs
# ==============================================================================
import asyncio
import sys
import os
import logging
from core.observability.otel_helpers import timed_span
from pathlib import Path
from typing import Dict, Any

from autogen import ConversableAgent
from .file_manager import workflow_file_manager

logger = logging.getLogger(__name__)

async def define_agents(workflow_name: str):
    """
    Define agents with unified transport channel - fully workflow-agnostic.
    Loads agent configurations from modular YAML files.
    
    Args:
        workflow_name: Name of the workflow to load agents for
        
    Returns:
        Dictionary of agent instances
    """
    
    logger.info(f"üèóÔ∏è [AGENTS] Creating agents for workflow: {workflow_name}")
    import time
    from time import perf_counter
    start_time = perf_counter()

    # Load workflow configuration using file manager
    workflow_config = workflow_file_manager.load_workflow(workflow_name)
    
    if not workflow_config:
        logger.error(f"‚ùå [AGENTS] No configuration found for workflow: {workflow_name}")
        return {}
    
    agent_configs = workflow_config.get('agents', {})
    
    # Handle nested structure: agents -> agents -> agent_definitions
    if 'agents' in agent_configs:
        agent_configs = agent_configs['agents']
    
    logger.debug(f"üîß [AGENTS] Loading {len(agent_configs)} agent definitions")
    
    # Load a single base LLM config; per-agent structured configs will be resolved by registry
    logger.debug("üîß [AGENTS] Loading base LLM config...")
    try:
        from core.core_config import make_llm_config as _make_base_llm_config
        _, base_llm_config = await _make_base_llm_config(stream=True)
    except Exception as e:
        logger.error(f"‚ùå [AGENTS] Failed to load base LLM config: {e}")
        return {}
    logger.debug("‚úÖ [AGENTS] Base LLM config loaded")
    
    agents = {}

    # NOTE: UserProxyAgent is auto-generated by orchestration_patterns.py
    # based on workflow config human_in_the_loop flag. No need to create it here.
    
    # Create agents dynamically from YAML configuration
    for agent_name, agent_config in agent_configs.items():
        # Use centralized timed_span helper (adds mozaiks.* prefix and duration attr)
        with timed_span("agents.create", attributes={
            "workflow_name": workflow_name,
            "agent_name": agent_name,
        }):
            logger.debug(f"üîß [AGENTS] Creating agent '{agent_name}' dynamically from YAML config...")

            # Try to get structured model for this specific agent via registry
            try:
                from .structured_outputs import get_llm_for_workflow as _get_structured_llm
                _, llm_config = await _get_structured_llm(workflow_name, 'base', agent_name=agent_name)
            except Exception:
                # Fallback to base llm_config
                llm_config = base_llm_config

            # Create the agent with configuration from YAML
            agent = ConversableAgent(
                name=agent_name,
                system_message=agent_config.get('system_message', ''),
                llm_config=llm_config,
                human_input_mode=agent_config.get('human_input_mode', 'NEVER'),
                max_consecutive_auto_reply=agent_config.get('max_consecutive_auto_reply', 2)
            )

            agents[agent_name] = agent

            # Generic debugging for any agent created
            logger.debug(
                f"‚úÖ [AGENTS] Created '{agent_name}' with human_input_mode='{agent.human_input_mode}', "
                f"max_consecutive_auto_reply={agent.max_consecutive_auto_reply}, structured_model_bound={'response_format' in (llm_config or {})}"
            )

    # Completion log remains generic
    agent_count = len(agents)
    duration = perf_counter() - start_time
    logger.info(f"‚úÖ [AGENTS] Created {agent_count} agents for '{workflow_name}' in {duration:.2f}s")
    logger.debug(f"üîç [AGENTS] Agent names: {list(agents.keys())}")

    # NOTE: Tool registration is handled by the modular tool system
    logger.info("üîß [AGENTS] Tools registration handled by modular tool system")

    return agents